{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BA-Saga Pattern The implementation for the paper \" An Evaluation of Saga Pattern Implementation Technologies \" of the 13 th ZEUS Workshop can be found in the following release An Evaluation of Saga Pattern Implementation Technologies . This repository includes four implementations that realize an example travel application using orchestrated Sagas. Implementation using the Eventuate Tram and the Eventuate Tram Sagas framework using Netflix Conductor using Camunda using MicroProfile LRA The example travel application consists of three backend services: TravelService, HotelService and FlightService. For simplicity reasons, only the workflow for booking a trip has been implemented. Saga Pattern Realization Each directory contains several realizations using the respective technology: A basic implementation(*) for the mentioned trip booking scenario and up to four further implementations that extend the basic one: Directory Short Description * The travel application contains the workflow for booking a trip. *_Expandability-Evaluation A CustomerService extends the travel application to examine how easily a new service can be included. *_FailurePerf-Evaluation The application includes additional sections that provoke different failure scenarios given a certain input. *_ParallelExec-Evaluation If possible, some transactions within the BookTripSaga are executed in parallel. The same applies for some compensating transactions. *_Testability-Evaluation The project includes automatic tests for some Saga related parts of the implementation. For more information about the projects and their setups see the respective sections in this documentation: Camunda Implementation Eventuate Tram Implementation MicroProfile LRA Implementation Netflic Conductor Implementation Evaluation Criteria Catalog This section includes a detailed description of the criteria catalog that was used for the evaluation of the individual technologies and can be found here: Criteria Catalog . Evaluation Summary A summarization of the evaluation results for the individual technologies can be found here: Evaluation Summary .","title":"Home"},{"location":"#ba-saga-pattern","text":"The implementation for the paper \" An Evaluation of Saga Pattern Implementation Technologies \" of the 13 th ZEUS Workshop can be found in the following release An Evaluation of Saga Pattern Implementation Technologies . This repository includes four implementations that realize an example travel application using orchestrated Sagas. Implementation using the Eventuate Tram and the Eventuate Tram Sagas framework using Netflix Conductor using Camunda using MicroProfile LRA The example travel application consists of three backend services: TravelService, HotelService and FlightService. For simplicity reasons, only the workflow for booking a trip has been implemented.","title":"BA-Saga Pattern"},{"location":"#saga-pattern-realization","text":"Each directory contains several realizations using the respective technology: A basic implementation(*) for the mentioned trip booking scenario and up to four further implementations that extend the basic one: Directory Short Description * The travel application contains the workflow for booking a trip. *_Expandability-Evaluation A CustomerService extends the travel application to examine how easily a new service can be included. *_FailurePerf-Evaluation The application includes additional sections that provoke different failure scenarios given a certain input. *_ParallelExec-Evaluation If possible, some transactions within the BookTripSaga are executed in parallel. The same applies for some compensating transactions. *_Testability-Evaluation The project includes automatic tests for some Saga related parts of the implementation. For more information about the projects and their setups see the respective sections in this documentation: Camunda Implementation Eventuate Tram Implementation MicroProfile LRA Implementation Netflic Conductor Implementation","title":"Saga Pattern Realization"},{"location":"#evaluation-criteria-catalog","text":"This section includes a detailed description of the criteria catalog that was used for the evaluation of the individual technologies and can be found here: Criteria Catalog .","title":"Evaluation Criteria Catalog"},{"location":"#evaluation-summary","text":"A summarization of the evaluation results for the individual technologies can be found here: Evaluation Summary .","title":"Evaluation Summary"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2021 Karolin D\u00fcrr Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"Camunda/Camunda_Expandability/","text":"Camunda Expandability Evaluation This project is part of the evaluation of a Saga pattern implementation using the Camunda . The original Saga Pattern Realization with Camunda has been extended by a CustomerService in order to evaluate the expandability of an implementation using Eventuate Tram to realize the Saga pattern. The CustomerService has to authorize the customer before a hotel is being booked. Start the Application Run ./gradlew clean build Execute docker-compose up --no-start Execute docker-compose start mysql Execute docker-compose start travelservice Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html CustomerService http://localhost:8083/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available , use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" To simulate a Saga that fails because the customer validation failed , the customerId in the trip booking request has to be smaller than 1 , for example: { ... customerId: \"-1\" } Additionally, the Camunda Cockpit can be accessed via http://localhost:8090/ with the credentials: Username: admin | Password: admin The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info CustomerService http://localhost:8083/api/customers/monitor/health http://localhost:8083/api/customers/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP). Stop the Application To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans Code Link Camunda_Implementations/Camunda_Expandability-Evaluation","title":"Expandability Evaluation"},{"location":"Camunda/Camunda_Expandability/#camunda-expandability-evaluation","text":"This project is part of the evaluation of a Saga pattern implementation using the Camunda . The original Saga Pattern Realization with Camunda has been extended by a CustomerService in order to evaluate the expandability of an implementation using Eventuate Tram to realize the Saga pattern. The CustomerService has to authorize the customer before a hotel is being booked.","title":"Camunda Expandability Evaluation"},{"location":"Camunda/Camunda_Expandability/#start-the-application","text":"Run ./gradlew clean build Execute docker-compose up --no-start Execute docker-compose start mysql Execute docker-compose start travelservice Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html CustomerService http://localhost:8083/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available , use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" To simulate a Saga that fails because the customer validation failed , the customerId in the trip booking request has to be smaller than 1 , for example: { ... customerId: \"-1\" } Additionally, the Camunda Cockpit can be accessed via http://localhost:8090/ with the credentials: Username: admin | Password: admin The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info CustomerService http://localhost:8083/api/customers/monitor/health http://localhost:8083/api/customers/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP).","title":"Start the Application"},{"location":"Camunda/Camunda_Expandability/#stop-the-application","text":"To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans","title":"Stop the Application"},{"location":"Camunda/Camunda_Expandability/#code-link","text":"Camunda_Implementations/Camunda_Expandability-Evaluation","title":"Code Link"},{"location":"Camunda/Camunda_FailurePerf/","text":"Camunda Fault Tolerance Evaluation This project is part of the evaluation of a Saga pattern implementation using the Camunda . Additional sections to the original Saga Pattern Realization with Camunda have been included that simulate different failure scenarios given a particular input. Start the Application Run ./gradlew clean build Execute docker-compose up --no-start Execute docker-compose start mysql Execute docker-compose start travelservice Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available , use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" Additionally, the Camunda Cockpit can be accessed via http://localhost:8090/ with the credentials: Username: admin | Password: admin The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP). Stop the Application To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans Provoke Failure Scenarios The respective String has to be used as destination country in the trip booking request to provoke a participant failure. An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Provoke orchestrator failure while starting trip booking\" , \"city\" : \"Bamberg\" }, \"travellerName\" : \"Orchestrator Start\" , \"boardType\" : \"All-inclusive\" , \"customerId\" : \"4\" } 1. Saga Participant Failure Provoke a failure of the FlightService participant before it started to execute a local transaction with the following string as destination country : \"Provoke participant failure before receiving task\" The HotelService terminates then the docker container of the FlightService while it is executing the bookHotel request. Afterwards, the FlightService has to be restarted manually to investigate what happens as soon as the service is running again. This can be done using one of the following commands: docker-compose start flightservice docker start flightservice_camundaFailurePerf If the container name of the FlightService has been changed in the docker-compose.yml file, the container has to be started using this name. Provoke a termination failure of the FlightService participant while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke participant failure while executing\" The FlightService forces then its JVM to terminate itself, after booking a flight but before informing the orchestrator about it, in order to simulate a sudden failure of the system. Afterwards, the FlightService , again, has to be restarted using the same commands as above. Provoke an exception in the FlightService participant while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke exception while executing\" The FlightService throws then a RuntimeException while booking a flight to simulate unexpected behaviour of the system. Afterwards, the behaviour of the service can be observed. The easiest way is to have a look at the log of the FlightService during that time. This can be done using the following command: docker logs flightservice_camundaFailurePerf --follow 2. Saga Orchestrator Failure The Camunda Engine within the TravelService plays the orchestrator role in this example application. Consequently, observing the system's behaviour during orchestrator failures involves failures of the TravelService . Provoke a failure of the TravelService while a trip booking is being started is not considered, since the TravelService is needed in order to make booking requests. Provoke a failure of the TravelService while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke orchestrator failure while executing\" The FlightService terminates then the docker container of the TravelService after booking a flight, but before informing the orchestrator about it. Afterwards, the TravelService has to be restarted manually to investigate what happens as soon as the service is running again. This can be done using one of the following commands: docker-compose start travelservice docker start travelservice_camundaFailurePerf If the container name of the TravelService has been changed in the docker-compose.yml file, the container has to be started using this name. 3. Breach of Saga Protocol A participant might send the same message twice to the orchestrator, or even send an old one. Therefore, two scenarios have been added to the implementation that provoke sending either an old or a duplicate message to the orchestrator in order to evaluate how an implementation using Camunda handles this situation. Provoke the HotelService to send a duplicate message to the TravelService with the following string as destination country : \"Provoke duplicate message to orchestrator\" The HotelService informs then Camunda's ExternalTaskSerice to complete the ExternalTask again with the respective message, this case the BookHotelResponse . Provoke the HotelService to send an old message to the TravelService with the following string as destination country : \"Provoke sending old message to orchestrator\" The HotelService creates then a new thread that waits for five minutes before it sends the same answer as before to the TravelService again. To achieve this, the HotelService sends the old message, in this case the BookHotelResponse , to the provided endpoint /external-task/{taskId}/complete . The service's logs document when it sends the old message. Code Link Camunda_Implementations/Camunda_FailurePerf-Evaluation","title":"Fault Tolerance Evaluation"},{"location":"Camunda/Camunda_FailurePerf/#camunda-fault-tolerance-evaluation","text":"This project is part of the evaluation of a Saga pattern implementation using the Camunda . Additional sections to the original Saga Pattern Realization with Camunda have been included that simulate different failure scenarios given a particular input.","title":"Camunda Fault Tolerance Evaluation"},{"location":"Camunda/Camunda_FailurePerf/#start-the-application","text":"Run ./gradlew clean build Execute docker-compose up --no-start Execute docker-compose start mysql Execute docker-compose start travelservice Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available , use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" Additionally, the Camunda Cockpit can be accessed via http://localhost:8090/ with the credentials: Username: admin | Password: admin The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP).","title":"Start the Application"},{"location":"Camunda/Camunda_FailurePerf/#stop-the-application","text":"To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans","title":"Stop the Application"},{"location":"Camunda/Camunda_FailurePerf/#provoke-failure-scenarios","text":"The respective String has to be used as destination country in the trip booking request to provoke a participant failure. An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Provoke orchestrator failure while starting trip booking\" , \"city\" : \"Bamberg\" }, \"travellerName\" : \"Orchestrator Start\" , \"boardType\" : \"All-inclusive\" , \"customerId\" : \"4\" }","title":"Provoke Failure Scenarios"},{"location":"Camunda/Camunda_FailurePerf/#1-saga-participant-failure","text":"Provoke a failure of the FlightService participant before it started to execute a local transaction with the following string as destination country : \"Provoke participant failure before receiving task\" The HotelService terminates then the docker container of the FlightService while it is executing the bookHotel request. Afterwards, the FlightService has to be restarted manually to investigate what happens as soon as the service is running again. This can be done using one of the following commands: docker-compose start flightservice docker start flightservice_camundaFailurePerf If the container name of the FlightService has been changed in the docker-compose.yml file, the container has to be started using this name. Provoke a termination failure of the FlightService participant while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke participant failure while executing\" The FlightService forces then its JVM to terminate itself, after booking a flight but before informing the orchestrator about it, in order to simulate a sudden failure of the system. Afterwards, the FlightService , again, has to be restarted using the same commands as above. Provoke an exception in the FlightService participant while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke exception while executing\" The FlightService throws then a RuntimeException while booking a flight to simulate unexpected behaviour of the system. Afterwards, the behaviour of the service can be observed. The easiest way is to have a look at the log of the FlightService during that time. This can be done using the following command: docker logs flightservice_camundaFailurePerf --follow","title":"1. Saga Participant Failure"},{"location":"Camunda/Camunda_FailurePerf/#2-saga-orchestrator-failure","text":"The Camunda Engine within the TravelService plays the orchestrator role in this example application. Consequently, observing the system's behaviour during orchestrator failures involves failures of the TravelService . Provoke a failure of the TravelService while a trip booking is being started is not considered, since the TravelService is needed in order to make booking requests. Provoke a failure of the TravelService while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke orchestrator failure while executing\" The FlightService terminates then the docker container of the TravelService after booking a flight, but before informing the orchestrator about it. Afterwards, the TravelService has to be restarted manually to investigate what happens as soon as the service is running again. This can be done using one of the following commands: docker-compose start travelservice docker start travelservice_camundaFailurePerf If the container name of the TravelService has been changed in the docker-compose.yml file, the container has to be started using this name.","title":"2. Saga Orchestrator Failure"},{"location":"Camunda/Camunda_FailurePerf/#3-breach-of-saga-protocol","text":"A participant might send the same message twice to the orchestrator, or even send an old one. Therefore, two scenarios have been added to the implementation that provoke sending either an old or a duplicate message to the orchestrator in order to evaluate how an implementation using Camunda handles this situation. Provoke the HotelService to send a duplicate message to the TravelService with the following string as destination country : \"Provoke duplicate message to orchestrator\" The HotelService informs then Camunda's ExternalTaskSerice to complete the ExternalTask again with the respective message, this case the BookHotelResponse . Provoke the HotelService to send an old message to the TravelService with the following string as destination country : \"Provoke sending old message to orchestrator\" The HotelService creates then a new thread that waits for five minutes before it sends the same answer as before to the TravelService again. To achieve this, the HotelService sends the old message, in this case the BookHotelResponse , to the provided endpoint /external-task/{taskId}/complete . The service's logs document when it sends the old message.","title":"3. Breach of Saga Protocol"},{"location":"Camunda/Camunda_FailurePerf/#code-link","text":"Camunda_Implementations/Camunda_FailurePerf-Evaluation","title":"Code Link"},{"location":"Camunda/Camunda_General/","text":"Saga Pattern Realization With Camunda This project includes an example implementation of the Saga pattern using Camunda . The example application represents a travel application that consists of three backend services: TravelService, HotelService and FlightService. For simplicity reasons, only the workflow for booking a trip has been implemented. Start the Application Run ./gradlew clean build Execute docker-compose up --no-start Execute docker-compose start mysql Execute docker-compose start travelservice Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP). Stop the Application To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans General Saga Characteristics External Compensation Trigger In order to start the compensation of a currently running Saga externally, a BPMN error has to be created for a scheduled or still unfinished task. Before the BPMN error can be created, the task has to be fetched and locked if not an already existing worker has done that. To achieve that, the following request, supplemented with the missing information, has to be sent as POST request to the engine at: http://localhost:8090/engine-rest/external-task/fetchAndLock . Since the implementation uses mainly external tasks, the BPMN error will be created for an external task which means the request is sent to the engine's /external-task endpoint. If an existing worker has already fetched the respective task, this request can be skipped. { \"workerId\" : \"Any name, e.g. compensationProvoker\" , \"maxTasks\" : 2 , \"usePriority\" : true , \"topics\" : [ { \"topicName\" : \"Name of the topic where the task will be sent to, e.g. bookFlight\" , \"lockDuration\" : 10000 } ] } Now that the respective task is locked and fetched, a BPMN error can be created. Therefore, the following request supplemented with the missing information has to be sent as POST request to the engine at: http://localhost:8090/engine-rest/external-task/{taskId}/bpmnError { \"workerId\" : \"Name specified in previous request: compensationProvoker\" , \"errorCode\" : \"Error Code that triggers the compensation event (check the bpmn definition for that), e.g. FLIGHT_ERROR\" , \"errorMessage\" : \"Any message: Provoke compensation externally\" } The TravelApplication.json insomnia file also includes these requests within the ExternalCompensationTrigger directory. Monitor the Application MySQL Database The camunda database, with its different tables, can be accessed with the following information, which is also included in the docker-compose.yaml file: User: mysqluser | Password: mysqlpw Camunda's Cockpit The cockpit can be accessed either just via http://localhost:8090/ or by using the whole path http://localhost:8090/camunda/app/welcome/default/#!/welcome . The following credentials are needed in order to be able to access the cockpit: Username: admin | Password: admin If the respective values have been changed in the application.properties file of the TravelService the new values have to be used for the username and the password. Log Files Each service provides a log that contains some information about it. The logs can be accessed using the name of the relevant container. The different logs can be accessed using the following commands: Log of Command to execute TravelService docker logs travelservice_camunda HotelService docker logs hotelservice_camunda FlightService docker logs flightservice_camunda By using the --follow supplement, it will be continued to stream the service's output to the console. The logging level can be changed in the respective application.properties file. Code Link Camunda_Implementations/Camunda","title":"Travel Application Realization"},{"location":"Camunda/Camunda_General/#saga-pattern-realization-with-camunda","text":"This project includes an example implementation of the Saga pattern using Camunda . The example application represents a travel application that consists of three backend services: TravelService, HotelService and FlightService. For simplicity reasons, only the workflow for booking a trip has been implemented.","title":"Saga Pattern Realization With Camunda"},{"location":"Camunda/Camunda_General/#start-the-application","text":"Run ./gradlew clean build Execute docker-compose up --no-start Execute docker-compose start mysql Execute docker-compose start travelservice Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP).","title":"Start the Application"},{"location":"Camunda/Camunda_General/#stop-the-application","text":"To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans","title":"Stop the Application"},{"location":"Camunda/Camunda_General/#general-saga-characteristics","text":"","title":"General Saga Characteristics"},{"location":"Camunda/Camunda_General/#external-compensation-trigger","text":"In order to start the compensation of a currently running Saga externally, a BPMN error has to be created for a scheduled or still unfinished task. Before the BPMN error can be created, the task has to be fetched and locked if not an already existing worker has done that. To achieve that, the following request, supplemented with the missing information, has to be sent as POST request to the engine at: http://localhost:8090/engine-rest/external-task/fetchAndLock . Since the implementation uses mainly external tasks, the BPMN error will be created for an external task which means the request is sent to the engine's /external-task endpoint. If an existing worker has already fetched the respective task, this request can be skipped. { \"workerId\" : \"Any name, e.g. compensationProvoker\" , \"maxTasks\" : 2 , \"usePriority\" : true , \"topics\" : [ { \"topicName\" : \"Name of the topic where the task will be sent to, e.g. bookFlight\" , \"lockDuration\" : 10000 } ] } Now that the respective task is locked and fetched, a BPMN error can be created. Therefore, the following request supplemented with the missing information has to be sent as POST request to the engine at: http://localhost:8090/engine-rest/external-task/{taskId}/bpmnError { \"workerId\" : \"Name specified in previous request: compensationProvoker\" , \"errorCode\" : \"Error Code that triggers the compensation event (check the bpmn definition for that), e.g. FLIGHT_ERROR\" , \"errorMessage\" : \"Any message: Provoke compensation externally\" } The TravelApplication.json insomnia file also includes these requests within the ExternalCompensationTrigger directory.","title":"External Compensation Trigger"},{"location":"Camunda/Camunda_General/#monitor-the-application","text":"","title":"Monitor the Application"},{"location":"Camunda/Camunda_General/#mysql-database","text":"The camunda database, with its different tables, can be accessed with the following information, which is also included in the docker-compose.yaml file: User: mysqluser | Password: mysqlpw","title":"MySQL Database"},{"location":"Camunda/Camunda_General/#camundas-cockpit","text":"The cockpit can be accessed either just via http://localhost:8090/ or by using the whole path http://localhost:8090/camunda/app/welcome/default/#!/welcome . The following credentials are needed in order to be able to access the cockpit: Username: admin | Password: admin If the respective values have been changed in the application.properties file of the TravelService the new values have to be used for the username and the password.","title":"Camunda's Cockpit"},{"location":"Camunda/Camunda_General/#log-files","text":"Each service provides a log that contains some information about it. The logs can be accessed using the name of the relevant container. The different logs can be accessed using the following commands: Log of Command to execute TravelService docker logs travelservice_camunda HotelService docker logs hotelservice_camunda FlightService docker logs flightservice_camunda By using the --follow supplement, it will be continued to stream the service's output to the console. The logging level can be changed in the respective application.properties file.","title":"Log Files"},{"location":"Camunda/Camunda_General/#code-link","text":"Camunda_Implementations/Camunda","title":"Code Link"},{"location":"Camunda/Camunda_ParallelExec/","text":"Saga Pattern Parallel Execution Evaluation This project includes an example implementation of the Saga pattern using Camunda . The difference to the original Saga Pattern Realization With Camunda is the parallel execution of specific tasks instead of a sequential one. Start the Application Run ./gradlew clean build Execute docker-compose up --no-start Execute docker-compose start mysql Execute docker-compose start travelservice Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" Additionally, the Camunda Cockpit can be accessed via http://localhost:8090/ with the credentials: Username: admin | Password: admin The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP). Stop the Application To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans Parallel Execution of Tasks The bookTrip , bookHotel and the bookFlight tasks, as well as the confirmHotel and the confirmTrip tasks, are now executed in parallel by using parallel gateways . Since the Camunda process engine is responsible for the invocation of the compensating transactions, this execution cannot be influenced. Code Link Camunda_Implementations/Camunda_ParallelExec-Evaluation","title":"Parallel Execution Evaluation"},{"location":"Camunda/Camunda_ParallelExec/#saga-pattern-parallel-execution-evaluation","text":"This project includes an example implementation of the Saga pattern using Camunda . The difference to the original Saga Pattern Realization With Camunda is the parallel execution of specific tasks instead of a sequential one.","title":"Saga Pattern Parallel Execution Evaluation"},{"location":"Camunda/Camunda_ParallelExec/#start-the-application","text":"Run ./gradlew clean build Execute docker-compose up --no-start Execute docker-compose start mysql Execute docker-compose start travelservice Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" Additionally, the Camunda Cockpit can be accessed via http://localhost:8090/ with the credentials: Username: admin | Password: admin The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP).","title":"Start the Application"},{"location":"Camunda/Camunda_ParallelExec/#stop-the-application","text":"To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans","title":"Stop the Application"},{"location":"Camunda/Camunda_ParallelExec/#parallel-execution-of-tasks","text":"The bookTrip , bookHotel and the bookFlight tasks, as well as the confirmHotel and the confirmTrip tasks, are now executed in parallel by using parallel gateways . Since the Camunda process engine is responsible for the invocation of the compensating transactions, this execution cannot be influenced.","title":"Parallel Execution of Tasks"},{"location":"Camunda/Camunda_ParallelExec/#code-link","text":"Camunda_Implementations/Camunda_ParallelExec-Evaluation","title":"Code Link"},{"location":"Camunda/Camunda_Testability/","text":"Camunda Testability Evaluation This project includes an example implementation of the Saga pattern using Camunda . The original Saga Pattern Realization With Camunda has been extended by automated tests that relate to the BookTripSaga. Start the Application Run ./gradlew clean build Execute docker-compose up --no-start Execute docker-compose start mysql Execute docker-compose start travelservice Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP). Stop the Application To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans Testability The TravelService as well as the HotelService have a testing directory that includes several tests concerning Saga-related code. 1. Unit Test Saga Definition Unit tests regarding the Saga orchestrator and the Saga definition can be found within the TravelService . Since Camunda provides a testing framework specifically designed for testing the BPMN process, it is used here. 2. Unit Test Saga Participant Examples for unit testing the Saga participant can be found within the HotelService . Unit tests for a Saga participant are realized using JUnit and Mockito . Code Link Camunda_Implementations/Camunda_Testability-Evaluation","title":"Testability Evaluation"},{"location":"Camunda/Camunda_Testability/#camunda-testability-evaluation","text":"This project includes an example implementation of the Saga pattern using Camunda . The original Saga Pattern Realization With Camunda has been extended by automated tests that relate to the BookTripSaga.","title":"Camunda Testability Evaluation"},{"location":"Camunda/Camunda_Testability/#start-the-application","text":"Run ./gradlew clean build Execute docker-compose up --no-start Execute docker-compose start mysql Execute docker-compose start travelservice Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP).","title":"Start the Application"},{"location":"Camunda/Camunda_Testability/#stop-the-application","text":"To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans","title":"Stop the Application"},{"location":"Camunda/Camunda_Testability/#testability","text":"The TravelService as well as the HotelService have a testing directory that includes several tests concerning Saga-related code.","title":"Testability"},{"location":"Camunda/Camunda_Testability/#1-unit-test-saga-definition","text":"Unit tests regarding the Saga orchestrator and the Saga definition can be found within the TravelService . Since Camunda provides a testing framework specifically designed for testing the BPMN process, it is used here.","title":"1. Unit Test Saga Definition"},{"location":"Camunda/Camunda_Testability/#2-unit-test-saga-participant","text":"Examples for unit testing the Saga participant can be found within the HotelService . Unit tests for a Saga participant are realized using JUnit and Mockito .","title":"2. Unit Test Saga Participant"},{"location":"Camunda/Camunda_Testability/#code-link","text":"Camunda_Implementations/Camunda_Testability-Evaluation","title":"Code Link"},{"location":"CriteriaCatalog/","text":"Evaluation Criteria Catalog In order to evaluate different technological approaches concerning the Saga pattern, some criteria have to be defined against which the evaluation can be performed. The following sections consider several areas of interest related to characteristics of microservices and the Saga pattern as well as some quality attributes of the ISO/IEC 25010 Quality Models 1 . For each area, the aspects that an evaluator should examine are explained and described. Some of the described criteria have been taken from the previous paper published by D\u00fcrr et al. [3] . The aim is to create a criteria catalog that can be used to analyze other technologies in this context. Table of Contents General Saga Characteristics Monitoring Expandability Fault Tolerance Security Testability Portability OSS Characteristics References [1] N. Alshuqayran, N. Ali, and R. Evans, \"A Systematic Mapping Study in Microservice Architecture.\" IEEE Computer Society, 2016, pp. 44\u201351. [Online]. Available: https://dx.doi.org/10.1109/SOCA.2016.15 [2] S. Newman, Building Microservices \u2013 Designing Fine\u2013Grained Systems, 1st ed. O\u2019Reilly Media, Inc., 2015, ISBN: 9781491950357. [3] K. D\u00fcrr, R. Lichtenth\u00e4ler, and G. Wirtz, \"An Evaluation of Saga Pattern Implementation Technologies,\" in Proceedings of the 13th European Workshop on Services and their Composition (ZEUS 2021), Bamberg, Germany, February 25\u201326, 2021, ser. CEUR Workshop Proceedings, vol. 2839. CEUR-WS.org, 2021, pp. 74\u201382. [Online]. Available: http://ceur-ws.org/Vol-2839/paper12.pdf [4] D. Cruz, T. Wieland, and A. Ziegler, \"Evaluation Criteria for Free/Open Source Software Products Based on Project Analysis,\" Software Process: Improvement and Practice, vol. 11, no. 2, pp. 107\u2013122, 2006. [Online]. Available: https://doi.org/10.1002/spip.257 [5] J. P. Confino and P. A. Laplante, \"An Open Source Software Evaluation Model,\" Int. J. Strateg. Inf. Technol. Appl., vol. 1, no. 1, pp. 60\u201377, 2010. [Online]. Available: https://doi.org/10.4018/jsita.2010101505 [6] T. Cerny, M. J. Donahoo, and M. Trnka, \"Contextual Understanding of Microservice Architecture: Current and Future Directions,\" ACM SIGAPP Applied Computing Review, vol. 17, no. 4, pp. 29\u201345, 2018. [Online]. Available: https://dx.doi.org/10.1145/3183628.3183631 [7] O. Zimmermann, \"Microservices Tenets,\" Computer Science \u2013 Research and Development, vol. 32, no. 3\u20134, pp. 301\u2013310, 2016. [Online]. Available: https://dx.doi.org/10.1007/s00450-016-0337-0 https://iso25000.com/index.php/en/iso-25000-standards/iso-25010?start=0 , last accessed 2021-07-06 \u21a9","title":"Criteria Catalog"},{"location":"CriteriaCatalog/#evaluation-criteria-catalog","text":"In order to evaluate different technological approaches concerning the Saga pattern, some criteria have to be defined against which the evaluation can be performed. The following sections consider several areas of interest related to characteristics of microservices and the Saga pattern as well as some quality attributes of the ISO/IEC 25010 Quality Models 1 . For each area, the aspects that an evaluator should examine are explained and described. Some of the described criteria have been taken from the previous paper published by D\u00fcrr et al. [3] . The aim is to create a criteria catalog that can be used to analyze other technologies in this context.","title":" Evaluation Criteria Catalog"},{"location":"CriteriaCatalog/#table-of-contents","text":"General Saga Characteristics Monitoring Expandability Fault Tolerance Security Testability Portability OSS Characteristics","title":"Table of Contents"},{"location":"CriteriaCatalog/#references","text":"[1] N. Alshuqayran, N. Ali, and R. Evans, \"A Systematic Mapping Study in Microservice Architecture.\" IEEE Computer Society, 2016, pp. 44\u201351. [Online]. Available: https://dx.doi.org/10.1109/SOCA.2016.15 [2] S. Newman, Building Microservices \u2013 Designing Fine\u2013Grained Systems, 1st ed. O\u2019Reilly Media, Inc., 2015, ISBN: 9781491950357. [3] K. D\u00fcrr, R. Lichtenth\u00e4ler, and G. Wirtz, \"An Evaluation of Saga Pattern Implementation Technologies,\" in Proceedings of the 13th European Workshop on Services and their Composition (ZEUS 2021), Bamberg, Germany, February 25\u201326, 2021, ser. CEUR Workshop Proceedings, vol. 2839. CEUR-WS.org, 2021, pp. 74\u201382. [Online]. Available: http://ceur-ws.org/Vol-2839/paper12.pdf [4] D. Cruz, T. Wieland, and A. Ziegler, \"Evaluation Criteria for Free/Open Source Software Products Based on Project Analysis,\" Software Process: Improvement and Practice, vol. 11, no. 2, pp. 107\u2013122, 2006. [Online]. Available: https://doi.org/10.1002/spip.257 [5] J. P. Confino and P. A. Laplante, \"An Open Source Software Evaluation Model,\" Int. J. Strateg. Inf. Technol. Appl., vol. 1, no. 1, pp. 60\u201377, 2010. [Online]. Available: https://doi.org/10.4018/jsita.2010101505 [6] T. Cerny, M. J. Donahoo, and M. Trnka, \"Contextual Understanding of Microservice Architecture: Current and Future Directions,\" ACM SIGAPP Applied Computing Review, vol. 17, no. 4, pp. 29\u201345, 2018. [Online]. Available: https://dx.doi.org/10.1145/3183628.3183631 [7] O. Zimmermann, \"Microservices Tenets,\" Computer Science \u2013 Research and Development, vol. 32, no. 3\u20134, pp. 301\u2013310, 2016. [Online]. Available: https://dx.doi.org/10.1007/s00450-016-0337-0 https://iso25000.com/index.php/en/iso-25000-standards/iso-25010?start=0 , last accessed 2021-07-06 \u21a9","title":"References"},{"location":"CriteriaCatalog/Expandability/","text":"Evaluation Criteria Catalog In order to evaluate different technological approaches concerning the Saga pattern, some criteria have to be defined against which the evaluation can be performed. The following sections consider several areas of interest related to characteristics of microservices and the Saga pattern as well as some quality attributes of the ISO/IEC 25010 Quality Models 1 . For each area, the aspects that an evaluator should examine are explained and described. Some of the described criteria have been taken from the previous paper published by D\u00fcrr et al. [3] . The aim is to create a criteria catalog that can be used to analyze other technologies in this context. Expandability Saga definitions might change over time, for example, when another service is being offered to the user or some functionality is no longer supported. This creates the necessity to update or extend existing definitions. Therefore, the following criteria examine different aspects that are relevant when modifying an existing Saga. Again, the used criteria originate from the evaluation done by D\u00fcrr et al. [3, p. 79 f.] . Terminating/ Pausing running Sagas Sagas for complex business workflows can potentially take days to complete. Thus, this criterion assesses whether the technology offers actions to deal with this situation, like stopping or pausing all ongoing Sagas. Versioning Sagas Instead of waiting for a Saga to finish or aborting it, the definition of different versions allows finishing Sagas of an old version while already starting new Sagas with the updated definition. This criterion analyzes if the technology offers this possibility. Built\u2013in language support This criterion comprises a listing of the programming languages the evaluated technology supports, for example, by offering a corresponding client or DSL . Any language for orchestrator Investigating whether the orchestrator can only be written using the supported built\u2013in language or any other programming language, for example, due to a provided API . Any language for participant One characteristic of microservices is that services can be realized using different technologies [ 2 , 7 ]. This criterion is similar to the one before. However, it determines if a participant can be written in any programming language and still participate in the Saga using the evaluated technology. References [1] N. Alshuqayran, N. Ali, and R. Evans, \"A Systematic Mapping Study in Microservice Architecture.\" IEEE Computer Society, 2016, pp. 44\u201351. [Online]. Available: https://dx.doi.org/10.1109/SOCA.2016.15 [2] S. Newman, Building Microservices \u2013 Designing Fine\u2013Grained Systems, 1st ed. O\u2019Reilly Media, Inc., 2015, ISBN: 9781491950357. [3] K. D\u00fcrr, R. Lichtenth\u00e4ler, and G. Wirtz, \"An Evaluation of Saga Pattern Implementation Technologies,\" in Proceedings of the 13th European Workshop on Services and their Composition (ZEUS 2021), Bamberg, Germany, February 25\u201326, 2021, ser. CEUR Workshop Proceedings, vol. 2839. CEUR-WS.org, 2021, pp. 74\u201382. [Online]. Available: http://ceur-ws.org/Vol-2839/paper12.pdf [4] D. Cruz, T. Wieland, and A. Ziegler, \"Evaluation Criteria for Free/Open Source Software Products Based on Project Analysis,\" Software Process: Improvement and Practice, vol. 11, no. 2, pp. 107\u2013122, 2006. [Online]. Available: https://doi.org/10.1002/spip.257 [5] J. P. Confino and P. A. Laplante, \"An Open Source Software Evaluation Model,\" Int. J. Strateg. Inf. Technol. Appl., vol. 1, no. 1, pp. 60\u201377, 2010. [Online]. Available: https://doi.org/10.4018/jsita.2010101505 [6] T. Cerny, M. J. Donahoo, and M. Trnka, \"Contextual Understanding of Microservice Architecture: Current and Future Directions,\" ACM SIGAPP Applied Computing Review, vol. 17, no. 4, pp. 29\u201345, 2018. [Online]. Available: https://dx.doi.org/10.1145/3183628.3183631 [7] O. Zimmermann, \"Microservices Tenets,\" Computer Science \u2013 Research and Development, vol. 32, no. 3\u20134, pp. 301\u2013310, 2016. [Online]. Available: https://dx.doi.org/10.1007/s00450-016-0337-0 https://iso25000.com/index.php/en/iso-25000-standards/iso-25010?start=0 , last accessed 2021-07-06 \u21a9","title":"Expandability"},{"location":"CriteriaCatalog/Expandability/#evaluation-criteria-catalog","text":"In order to evaluate different technological approaches concerning the Saga pattern, some criteria have to be defined against which the evaluation can be performed. The following sections consider several areas of interest related to characteristics of microservices and the Saga pattern as well as some quality attributes of the ISO/IEC 25010 Quality Models 1 . For each area, the aspects that an evaluator should examine are explained and described. Some of the described criteria have been taken from the previous paper published by D\u00fcrr et al. [3] . The aim is to create a criteria catalog that can be used to analyze other technologies in this context.","title":" Evaluation Criteria Catalog"},{"location":"CriteriaCatalog/Expandability/#expandability","text":"Saga definitions might change over time, for example, when another service is being offered to the user or some functionality is no longer supported. This creates the necessity to update or extend existing definitions. Therefore, the following criteria examine different aspects that are relevant when modifying an existing Saga. Again, the used criteria originate from the evaluation done by D\u00fcrr et al. [3, p. 79 f.] .","title":"Expandability"},{"location":"CriteriaCatalog/Expandability/#terminating-pausing-running-sagas","text":"Sagas for complex business workflows can potentially take days to complete. Thus, this criterion assesses whether the technology offers actions to deal with this situation, like stopping or pausing all ongoing Sagas.","title":"Terminating/ Pausing running Sagas"},{"location":"CriteriaCatalog/Expandability/#versioning-sagas","text":"Instead of waiting for a Saga to finish or aborting it, the definition of different versions allows finishing Sagas of an old version while already starting new Sagas with the updated definition. This criterion analyzes if the technology offers this possibility.","title":"Versioning Sagas"},{"location":"CriteriaCatalog/Expandability/#builtin-language-support","text":"This criterion comprises a listing of the programming languages the evaluated technology supports, for example, by offering a corresponding client or DSL .","title":"Built\u2013in language support"},{"location":"CriteriaCatalog/Expandability/#any-language-for-orchestrator","text":"Investigating whether the orchestrator can only be written using the supported built\u2013in language or any other programming language, for example, due to a provided API .","title":"Any language for orchestrator"},{"location":"CriteriaCatalog/Expandability/#any-language-for-participant","text":"One characteristic of microservices is that services can be realized using different technologies [ 2 , 7 ]. This criterion is similar to the one before. However, it determines if a participant can be written in any programming language and still participate in the Saga using the evaluated technology.","title":"Any language for participant"},{"location":"CriteriaCatalog/Expandability/#references","text":"[1] N. Alshuqayran, N. Ali, and R. Evans, \"A Systematic Mapping Study in Microservice Architecture.\" IEEE Computer Society, 2016, pp. 44\u201351. [Online]. Available: https://dx.doi.org/10.1109/SOCA.2016.15 [2] S. Newman, Building Microservices \u2013 Designing Fine\u2013Grained Systems, 1st ed. O\u2019Reilly Media, Inc., 2015, ISBN: 9781491950357. [3] K. D\u00fcrr, R. Lichtenth\u00e4ler, and G. Wirtz, \"An Evaluation of Saga Pattern Implementation Technologies,\" in Proceedings of the 13th European Workshop on Services and their Composition (ZEUS 2021), Bamberg, Germany, February 25\u201326, 2021, ser. CEUR Workshop Proceedings, vol. 2839. CEUR-WS.org, 2021, pp. 74\u201382. [Online]. Available: http://ceur-ws.org/Vol-2839/paper12.pdf [4] D. Cruz, T. Wieland, and A. Ziegler, \"Evaluation Criteria for Free/Open Source Software Products Based on Project Analysis,\" Software Process: Improvement and Practice, vol. 11, no. 2, pp. 107\u2013122, 2006. [Online]. Available: https://doi.org/10.1002/spip.257 [5] J. P. Confino and P. A. Laplante, \"An Open Source Software Evaluation Model,\" Int. J. Strateg. Inf. Technol. Appl., vol. 1, no. 1, pp. 60\u201377, 2010. [Online]. Available: https://doi.org/10.4018/jsita.2010101505 [6] T. Cerny, M. J. Donahoo, and M. Trnka, \"Contextual Understanding of Microservice Architecture: Current and Future Directions,\" ACM SIGAPP Applied Computing Review, vol. 17, no. 4, pp. 29\u201345, 2018. [Online]. Available: https://dx.doi.org/10.1145/3183628.3183631 [7] O. Zimmermann, \"Microservices Tenets,\" Computer Science \u2013 Research and Development, vol. 32, no. 3\u20134, pp. 301\u2013310, 2016. [Online]. Available: https://dx.doi.org/10.1007/s00450-016-0337-0 https://iso25000.com/index.php/en/iso-25000-standards/iso-25010?start=0 , last accessed 2021-07-06 \u21a9","title":"References"},{"location":"CriteriaCatalog/FaultTolerance/","text":"Evaluation Criteria Catalog In order to evaluate different technological approaches concerning the Saga pattern, some criteria have to be defined against which the evaluation can be performed. The following sections consider several areas of interest related to characteristics of microservices and the Saga pattern as well as some quality attributes of the ISO/IEC 25010 Quality Models 1 . For each area, the aspects that an evaluator should examine are explained and described. Some of the described criteria have been taken from the previous paper published by D\u00fcrr et al. [3] . The aim is to create a criteria catalog that can be used to analyze other technologies in this context. Fault Tolerance Since the MSA represents a distributed system, failures have to be expected and the different services have to tolerate them. Therefore, the following criteria concentrate on determining the behaviour of a technology when failures of either the orchestrator or the participant occur. For this purpose, corresponding error scenarios should be simulated with the technology to be evaluated. More information on how such error scenarios were simulated with the different technologies can be found within the respective fault tolerance implementations. Execution timeouts The definition of execution timeouts for individual transactions or even for the entire Saga can be a desirable feature to prevent the possibility of infinite waiting. Then again, enforced timeouts are problematic when timeouts should not abort Sagas. This criterion relates to \"Enforced execution timeouts\" in [3, p. 79 ff.] . Reaction to participant fault An examination of the behaviour of the orchestrator and the participant if a failure arises within a participant. Several failure scenarios are possible: the participant fails before receiving a message or while executing a local transaction. In addition, a failure during execution can either be a sudden failure like the service crashes or unexpected behaviour such as throwing an exception. These failures happen before the service could return its answer to the orchestrator. The criterion is based upon the \"Retry of failing participant without restart\" criterion in [3, p. 79 ff.] . Saga continuation trigger after orchestrator crash Since not only a participant can fail, faults have to be also taken into account for the orchestrator. An orchestrator should be able to continue a Saga where it left off, even if it crashed during its execution. Particularly interesting here is the trigger of such a continuation after the orchestrator crashed and becomes available again. This criterion is related to the \"Auto\u2013continuation after orchestrator crash\" criterion in [3, p. 79 ff.] . New Sagas while orchestrator unavailable Depending on who orchestrates the Saga execution and how the communication between the components is realized, it might be possible to start new Sagas even though the orchestrator is temporarily unavailable. This criterion was also part of D\u00fcrr et al.\u2019s evaluation [3, p. 79 ff.] . Independent compensating transactions This criterion is related to the Compensation transaction allocation criterion in the General Saga Characteristics . If compensating transactions can only be defined for the whole Saga, the compensation process needs all services listed in this process available to finish. Whereas, when only needed compensations are executed, only the services that already participated in the Saga have to be available during compensation. This criterion can also be found in [3, p. 79 ff.] . Orchestrator reaction to duplicate messages Another interesting aspect is how the technology reacts to non-compliance with the protocol. Therefore, this criterion aims to observe what happens when a participant sends duplicate messages to the orchestrator. This can be provoked by causing a participant to send a message twice in immediate succession. Orchestrator reaction to old messages Following on from the previous criterion, this time, old messages are resent to the orchestrator. A participant can simulate this by starting a new thread that resends the same message it is about to send to the orchestrator after some time, for example after five minutes. High availability This criterion considers if the technology allows achieving highly available systems, for example, by replicating the orchestrating engine. Analyzing High availability was also part of the evaluation done in [3, p. 79 ff.] . References [1] N. Alshuqayran, N. Ali, and R. Evans, \"A Systematic Mapping Study in Microservice Architecture.\" IEEE Computer Society, 2016, pp. 44\u201351. [Online]. Available: https://dx.doi.org/10.1109/SOCA.2016.15 [2] S. Newman, Building Microservices \u2013 Designing Fine\u2013Grained Systems, 1st ed. O\u2019Reilly Media, Inc., 2015, ISBN: 9781491950357. [3] K. D\u00fcrr, R. Lichtenth\u00e4ler, and G. Wirtz, \"An Evaluation of Saga Pattern Implementation Technologies,\" in Proceedings of the 13th European Workshop on Services and their Composition (ZEUS 2021), Bamberg, Germany, February 25\u201326, 2021, ser. CEUR Workshop Proceedings, vol. 2839. CEUR-WS.org, 2021, pp. 74\u201382. [Online]. Available: http://ceur-ws.org/Vol-2839/paper12.pdf [4] D. Cruz, T. Wieland, and A. Ziegler, \"Evaluation Criteria for Free/Open Source Software Products Based on Project Analysis,\" Software Process: Improvement and Practice, vol. 11, no. 2, pp. 107\u2013122, 2006. [Online]. Available: https://doi.org/10.1002/spip.257 [5] J. P. Confino and P. A. Laplante, \"An Open Source Software Evaluation Model,\" Int. J. Strateg. Inf. Technol. Appl., vol. 1, no. 1, pp. 60\u201377, 2010. [Online]. Available: https://doi.org/10.4018/jsita.2010101505 [6] T. Cerny, M. J. Donahoo, and M. Trnka, \"Contextual Understanding of Microservice Architecture: Current and Future Directions,\" ACM SIGAPP Applied Computing Review, vol. 17, no. 4, pp. 29\u201345, 2018. [Online]. Available: https://dx.doi.org/10.1145/3183628.3183631 [7] O. Zimmermann, \"Microservices Tenets,\" Computer Science \u2013 Research and Development, vol. 32, no. 3\u20134, pp. 301\u2013310, 2016. [Online]. Available: https://dx.doi.org/10.1007/s00450-016-0337-0 https://iso25000.com/index.php/en/iso-25000-standards/iso-25010?start=0 , last accessed 2021-07-06 \u21a9","title":"Fault Tolerance"},{"location":"CriteriaCatalog/FaultTolerance/#evaluation-criteria-catalog","text":"In order to evaluate different technological approaches concerning the Saga pattern, some criteria have to be defined against which the evaluation can be performed. The following sections consider several areas of interest related to characteristics of microservices and the Saga pattern as well as some quality attributes of the ISO/IEC 25010 Quality Models 1 . For each area, the aspects that an evaluator should examine are explained and described. Some of the described criteria have been taken from the previous paper published by D\u00fcrr et al. [3] . The aim is to create a criteria catalog that can be used to analyze other technologies in this context.","title":" Evaluation Criteria Catalog"},{"location":"CriteriaCatalog/FaultTolerance/#fault-tolerance","text":"Since the MSA represents a distributed system, failures have to be expected and the different services have to tolerate them. Therefore, the following criteria concentrate on determining the behaviour of a technology when failures of either the orchestrator or the participant occur. For this purpose, corresponding error scenarios should be simulated with the technology to be evaluated. More information on how such error scenarios were simulated with the different technologies can be found within the respective fault tolerance implementations.","title":"Fault Tolerance"},{"location":"CriteriaCatalog/FaultTolerance/#execution-timeouts","text":"The definition of execution timeouts for individual transactions or even for the entire Saga can be a desirable feature to prevent the possibility of infinite waiting. Then again, enforced timeouts are problematic when timeouts should not abort Sagas. This criterion relates to \"Enforced execution timeouts\" in [3, p. 79 ff.] .","title":"Execution timeouts"},{"location":"CriteriaCatalog/FaultTolerance/#reaction-to-participant-fault","text":"An examination of the behaviour of the orchestrator and the participant if a failure arises within a participant. Several failure scenarios are possible: the participant fails before receiving a message or while executing a local transaction. In addition, a failure during execution can either be a sudden failure like the service crashes or unexpected behaviour such as throwing an exception. These failures happen before the service could return its answer to the orchestrator. The criterion is based upon the \"Retry of failing participant without restart\" criterion in [3, p. 79 ff.] .","title":"Reaction to participant fault"},{"location":"CriteriaCatalog/FaultTolerance/#saga-continuation-trigger-after-orchestrator-crash","text":"Since not only a participant can fail, faults have to be also taken into account for the orchestrator. An orchestrator should be able to continue a Saga where it left off, even if it crashed during its execution. Particularly interesting here is the trigger of such a continuation after the orchestrator crashed and becomes available again. This criterion is related to the \"Auto\u2013continuation after orchestrator crash\" criterion in [3, p. 79 ff.] .","title":"Saga continuation trigger after orchestrator crash"},{"location":"CriteriaCatalog/FaultTolerance/#new-sagas-while-orchestrator-unavailable","text":"Depending on who orchestrates the Saga execution and how the communication between the components is realized, it might be possible to start new Sagas even though the orchestrator is temporarily unavailable. This criterion was also part of D\u00fcrr et al.\u2019s evaluation [3, p. 79 ff.] .","title":"New Sagas while orchestrator unavailable"},{"location":"CriteriaCatalog/FaultTolerance/#independent-compensating-transactions","text":"This criterion is related to the Compensation transaction allocation criterion in the General Saga Characteristics . If compensating transactions can only be defined for the whole Saga, the compensation process needs all services listed in this process available to finish. Whereas, when only needed compensations are executed, only the services that already participated in the Saga have to be available during compensation. This criterion can also be found in [3, p. 79 ff.] .","title":"Independent compensating transactions"},{"location":"CriteriaCatalog/FaultTolerance/#orchestrator-reaction-to-duplicate-messages","text":"Another interesting aspect is how the technology reacts to non-compliance with the protocol. Therefore, this criterion aims to observe what happens when a participant sends duplicate messages to the orchestrator. This can be provoked by causing a participant to send a message twice in immediate succession.","title":"Orchestrator reaction to duplicate messages"},{"location":"CriteriaCatalog/FaultTolerance/#orchestrator-reaction-to-old-messages","text":"Following on from the previous criterion, this time, old messages are resent to the orchestrator. A participant can simulate this by starting a new thread that resends the same message it is about to send to the orchestrator after some time, for example after five minutes.","title":"Orchestrator reaction to old messages"},{"location":"CriteriaCatalog/FaultTolerance/#high-availability","text":"This criterion considers if the technology allows achieving highly available systems, for example, by replicating the orchestrating engine. Analyzing High availability was also part of the evaluation done in [3, p. 79 ff.] .","title":"High availability"},{"location":"CriteriaCatalog/FaultTolerance/#references","text":"[1] N. Alshuqayran, N. Ali, and R. Evans, \"A Systematic Mapping Study in Microservice Architecture.\" IEEE Computer Society, 2016, pp. 44\u201351. [Online]. Available: https://dx.doi.org/10.1109/SOCA.2016.15 [2] S. Newman, Building Microservices \u2013 Designing Fine\u2013Grained Systems, 1st ed. O\u2019Reilly Media, Inc., 2015, ISBN: 9781491950357. [3] K. D\u00fcrr, R. Lichtenth\u00e4ler, and G. Wirtz, \"An Evaluation of Saga Pattern Implementation Technologies,\" in Proceedings of the 13th European Workshop on Services and their Composition (ZEUS 2021), Bamberg, Germany, February 25\u201326, 2021, ser. CEUR Workshop Proceedings, vol. 2839. CEUR-WS.org, 2021, pp. 74\u201382. [Online]. Available: http://ceur-ws.org/Vol-2839/paper12.pdf [4] D. Cruz, T. Wieland, and A. Ziegler, \"Evaluation Criteria for Free/Open Source Software Products Based on Project Analysis,\" Software Process: Improvement and Practice, vol. 11, no. 2, pp. 107\u2013122, 2006. [Online]. Available: https://doi.org/10.1002/spip.257 [5] J. P. Confino and P. A. Laplante, \"An Open Source Software Evaluation Model,\" Int. J. Strateg. Inf. Technol. Appl., vol. 1, no. 1, pp. 60\u201377, 2010. [Online]. Available: https://doi.org/10.4018/jsita.2010101505 [6] T. Cerny, M. J. Donahoo, and M. Trnka, \"Contextual Understanding of Microservice Architecture: Current and Future Directions,\" ACM SIGAPP Applied Computing Review, vol. 17, no. 4, pp. 29\u201345, 2018. [Online]. Available: https://dx.doi.org/10.1145/3183628.3183631 [7] O. Zimmermann, \"Microservices Tenets,\" Computer Science \u2013 Research and Development, vol. 32, no. 3\u20134, pp. 301\u2013310, 2016. [Online]. Available: https://dx.doi.org/10.1007/s00450-016-0337-0 https://iso25000.com/index.php/en/iso-25000-standards/iso-25010?start=0 , last accessed 2021-07-06 \u21a9","title":"References"},{"location":"CriteriaCatalog/GeneralSagaCharacteristics/","text":"Evaluation Criteria Catalog In order to evaluate different technological approaches concerning the Saga pattern, some criteria have to be defined against which the evaluation can be performed. The following sections consider several areas of interest related to characteristics of microservices and the Saga pattern as well as some quality attributes of the ISO/IEC 25010 Quality Models 1 . For each area, the aspects that an evaluator should examine are explained and described. Some of the described criteria have been taken from the previous paper published by D\u00fcrr et al. [3] . The aim is to create a criteria catalog that can be used to analyze other technologies in this context. General Saga Characteristics The Saga pattern includes different characteristics like the definition of compensating transactions. Thus, the following criteria examine how the implementation technology supports realizing those characteristics or related matters. Saga definition As this paper focuses on orchestrated Sagas, the sequence of the included transactions has to be defined, for example in a JSON file or programmatically via a DSL . Therefore, this criterion describes the different possibilities the examined technology offers to define the individual Saga process with its included steps. Orchestrating services Depending on the particular implementation, the Saga orchestrator can be an additional service that exclusively orchestrates the Saga or an existing one that also participates in it. However, some technologies might already provide an orchestrating engine that orchestrates the actual process single\u2013handedly. Hence, an existing self\u2013implemented service cannot be used as the real orchestrator. Instead, it might have to register the Saga definition with the technology\u2019s orchestrator but otherwise constitutes merely a participant. As a result, this criterion analyzes which service or services represent the Saga orchestrator. The criterion idea was based on the \"No. of services for orchestration criterion\" in [3, p. 79] . Specifying compensating transactions Compensating transactions represent an essential aspect of the Saga pattern to undo previously done changes. Consequently, the technology should provide the possibility to define compensating transactions. This criterion was also part of the evaluation in [3, p. 79 f.] . Compensation transaction allocation Compensating previously done changes can be ensured using two ways: starting the compensation only for transactions that have been executed or always starting all compensating transactions of a Saga. This has different implications for the implementation, such as introducing the necessity to prevent failures if the orchestrator tries to compensate non\u2013executed transactions. Therefore, this criterion examines if a compensating transaction is allocated to the corresponding transaction or simply to the entire Saga. It is related to the \"Compensation only where needed criterion\" in [3, p. 79 f.] . Parallel execution of transactions To reduce the Saga\u2019s duration and improve performance, parallel execution of transactions can be preferable. Therefore, the technology\u2019s support of this is investigated here. D\u00fcrr et al. also used this in their analysis [3, p. 79 f.] . Parallel execution configurable There might exist transactions that have to be executed sequentially. Therefore, for technologies that allow parallel execution of transactions, the question arises if it is also possible to configure only certain transactions to be executed in parallel. Participant communication selectable The orchestrator and the participants can communicate in multiple ways, for example, using message brokers or HTTP requests. Therefore it is investigated whether a technology facilitates different communication possibilities or only one. External compensation trigger Situations might arise that require aborting a running Saga externally, for example to update the system. However, since some services might have already committed their changes, simply terminating the Saga will not be sufficient. So instead of aborting the Saga, it is advantageous if a possibility is offered to trigger the compensation mechanism for a running Saga. An example of such a possibility can be an API endpoint or a UI feature. Choreographed Sagas Sagas can also be organized using choreography instead of orchestration, which is why this criterion considers if a technology also supports implementing a choreographed approach. Another criterion that D\u00fcrr et al. also evaluated [3, p. 79 f.] . References [1] N. Alshuqayran, N. Ali, and R. Evans, \"A Systematic Mapping Study in Microservice Architecture.\" IEEE Computer Society, 2016, pp. 44\u201351. [Online]. Available: https://dx.doi.org/10.1109/SOCA.2016.15 [2] S. Newman, Building Microservices \u2013 Designing Fine\u2013Grained Systems, 1st ed. O\u2019Reilly Media, Inc., 2015, ISBN: 9781491950357. [3] K. D\u00fcrr, R. Lichtenth\u00e4ler, and G. Wirtz, \"An Evaluation of Saga Pattern Implementation Technologies,\" in Proceedings of the 13th European Workshop on Services and their Composition (ZEUS 2021), Bamberg, Germany, February 25\u201326, 2021, ser. CEUR Workshop Proceedings, vol. 2839. CEUR-WS.org, 2021, pp. 74\u201382. [Online]. Available: http://ceur-ws.org/Vol-2839/paper12.pdf [4] D. Cruz, T. Wieland, and A. Ziegler, \"Evaluation Criteria for Free/Open Source Software Products Based on Project Analysis,\" Software Process: Improvement and Practice, vol. 11, no. 2, pp. 107\u2013122, 2006. [Online]. Available: https://doi.org/10.1002/spip.257 [5] J. P. Confino and P. A. Laplante, \"An Open Source Software Evaluation Model,\" Int. J. Strateg. Inf. Technol. Appl., vol. 1, no. 1, pp. 60\u201377, 2010. [Online]. Available: https://doi.org/10.4018/jsita.2010101505 [6] T. Cerny, M. J. Donahoo, and M. Trnka, \"Contextual Understanding of Microservice Architecture: Current and Future Directions,\" ACM SIGAPP Applied Computing Review, vol. 17, no. 4, pp. 29\u201345, 2018. [Online]. Available: https://dx.doi.org/10.1145/3183628.3183631 [7] O. Zimmermann, \"Microservices Tenets,\" Computer Science \u2013 Research and Development, vol. 32, no. 3\u20134, pp. 301\u2013310, 2016. [Online]. Available: https://dx.doi.org/10.1007/s00450-016-0337-0 https://iso25000.com/index.php/en/iso-25000-standards/iso-25010?start=0 , last accessed 2021-07-06 \u21a9","title":"General Saga Characteristics"},{"location":"CriteriaCatalog/GeneralSagaCharacteristics/#evaluation-criteria-catalog","text":"In order to evaluate different technological approaches concerning the Saga pattern, some criteria have to be defined against which the evaluation can be performed. The following sections consider several areas of interest related to characteristics of microservices and the Saga pattern as well as some quality attributes of the ISO/IEC 25010 Quality Models 1 . For each area, the aspects that an evaluator should examine are explained and described. Some of the described criteria have been taken from the previous paper published by D\u00fcrr et al. [3] . The aim is to create a criteria catalog that can be used to analyze other technologies in this context.","title":" Evaluation Criteria Catalog"},{"location":"CriteriaCatalog/GeneralSagaCharacteristics/#general-saga-characteristics","text":"The Saga pattern includes different characteristics like the definition of compensating transactions. Thus, the following criteria examine how the implementation technology supports realizing those characteristics or related matters.","title":"General Saga Characteristics"},{"location":"CriteriaCatalog/GeneralSagaCharacteristics/#saga-definition","text":"As this paper focuses on orchestrated Sagas, the sequence of the included transactions has to be defined, for example in a JSON file or programmatically via a DSL . Therefore, this criterion describes the different possibilities the examined technology offers to define the individual Saga process with its included steps.","title":"Saga definition"},{"location":"CriteriaCatalog/GeneralSagaCharacteristics/#orchestrating-services","text":"Depending on the particular implementation, the Saga orchestrator can be an additional service that exclusively orchestrates the Saga or an existing one that also participates in it. However, some technologies might already provide an orchestrating engine that orchestrates the actual process single\u2013handedly. Hence, an existing self\u2013implemented service cannot be used as the real orchestrator. Instead, it might have to register the Saga definition with the technology\u2019s orchestrator but otherwise constitutes merely a participant. As a result, this criterion analyzes which service or services represent the Saga orchestrator. The criterion idea was based on the \"No. of services for orchestration criterion\" in [3, p. 79] .","title":"Orchestrating services"},{"location":"CriteriaCatalog/GeneralSagaCharacteristics/#specifying-compensating-transactions","text":"Compensating transactions represent an essential aspect of the Saga pattern to undo previously done changes. Consequently, the technology should provide the possibility to define compensating transactions. This criterion was also part of the evaluation in [3, p. 79 f.] .","title":"Specifying compensating transactions"},{"location":"CriteriaCatalog/GeneralSagaCharacteristics/#compensation-transaction-allocation","text":"Compensating previously done changes can be ensured using two ways: starting the compensation only for transactions that have been executed or always starting all compensating transactions of a Saga. This has different implications for the implementation, such as introducing the necessity to prevent failures if the orchestrator tries to compensate non\u2013executed transactions. Therefore, this criterion examines if a compensating transaction is allocated to the corresponding transaction or simply to the entire Saga. It is related to the \"Compensation only where needed criterion\" in [3, p. 79 f.] .","title":"Compensation transaction allocation"},{"location":"CriteriaCatalog/GeneralSagaCharacteristics/#parallel-execution-of-transactions","text":"To reduce the Saga\u2019s duration and improve performance, parallel execution of transactions can be preferable. Therefore, the technology\u2019s support of this is investigated here. D\u00fcrr et al. also used this in their analysis [3, p. 79 f.] .","title":"Parallel execution of transactions"},{"location":"CriteriaCatalog/GeneralSagaCharacteristics/#parallel-execution-configurable","text":"There might exist transactions that have to be executed sequentially. Therefore, for technologies that allow parallel execution of transactions, the question arises if it is also possible to configure only certain transactions to be executed in parallel.","title":"Parallel execution configurable"},{"location":"CriteriaCatalog/GeneralSagaCharacteristics/#participant-communication-selectable","text":"The orchestrator and the participants can communicate in multiple ways, for example, using message brokers or HTTP requests. Therefore it is investigated whether a technology facilitates different communication possibilities or only one.","title":"Participant communication selectable"},{"location":"CriteriaCatalog/GeneralSagaCharacteristics/#external-compensation-trigger","text":"Situations might arise that require aborting a running Saga externally, for example to update the system. However, since some services might have already committed their changes, simply terminating the Saga will not be sufficient. So instead of aborting the Saga, it is advantageous if a possibility is offered to trigger the compensation mechanism for a running Saga. An example of such a possibility can be an API endpoint or a UI feature.","title":"External compensation trigger"},{"location":"CriteriaCatalog/GeneralSagaCharacteristics/#choreographed-sagas","text":"Sagas can also be organized using choreography instead of orchestration, which is why this criterion considers if a technology also supports implementing a choreographed approach. Another criterion that D\u00fcrr et al. also evaluated [3, p. 79 f.] .","title":"Choreographed Sagas"},{"location":"CriteriaCatalog/GeneralSagaCharacteristics/#references","text":"[1] N. Alshuqayran, N. Ali, and R. Evans, \"A Systematic Mapping Study in Microservice Architecture.\" IEEE Computer Society, 2016, pp. 44\u201351. [Online]. Available: https://dx.doi.org/10.1109/SOCA.2016.15 [2] S. Newman, Building Microservices \u2013 Designing Fine\u2013Grained Systems, 1st ed. O\u2019Reilly Media, Inc., 2015, ISBN: 9781491950357. [3] K. D\u00fcrr, R. Lichtenth\u00e4ler, and G. Wirtz, \"An Evaluation of Saga Pattern Implementation Technologies,\" in Proceedings of the 13th European Workshop on Services and their Composition (ZEUS 2021), Bamberg, Germany, February 25\u201326, 2021, ser. CEUR Workshop Proceedings, vol. 2839. CEUR-WS.org, 2021, pp. 74\u201382. [Online]. Available: http://ceur-ws.org/Vol-2839/paper12.pdf [4] D. Cruz, T. Wieland, and A. Ziegler, \"Evaluation Criteria for Free/Open Source Software Products Based on Project Analysis,\" Software Process: Improvement and Practice, vol. 11, no. 2, pp. 107\u2013122, 2006. [Online]. Available: https://doi.org/10.1002/spip.257 [5] J. P. Confino and P. A. Laplante, \"An Open Source Software Evaluation Model,\" Int. J. Strateg. Inf. Technol. Appl., vol. 1, no. 1, pp. 60\u201377, 2010. [Online]. Available: https://doi.org/10.4018/jsita.2010101505 [6] T. Cerny, M. J. Donahoo, and M. Trnka, \"Contextual Understanding of Microservice Architecture: Current and Future Directions,\" ACM SIGAPP Applied Computing Review, vol. 17, no. 4, pp. 29\u201345, 2018. [Online]. Available: https://dx.doi.org/10.1145/3183628.3183631 [7] O. Zimmermann, \"Microservices Tenets,\" Computer Science \u2013 Research and Development, vol. 32, no. 3\u20134, pp. 301\u2013310, 2016. [Online]. Available: https://dx.doi.org/10.1007/s00450-016-0337-0 https://iso25000.com/index.php/en/iso-25000-standards/iso-25010?start=0 , last accessed 2021-07-06 \u21a9","title":"References"},{"location":"CriteriaCatalog/Monitoring/","text":"Evaluation Criteria Catalog In order to evaluate different technological approaches concerning the Saga pattern, some criteria have to be defined against which the evaluation can be performed. The following sections consider several areas of interest related to characteristics of microservices and the Saga pattern as well as some quality attributes of the ISO/IEC 25010 Quality Models 1 . For each area, the aspects that an evaluator should examine are explained and described. Some of the described criteria have been taken from the previous paper published by D\u00fcrr et al. [3] . The aim is to create a criteria catalog that can be used to analyze other technologies in this context. Monitoring Since a Saga can be a transaction that takes a long time to finish, investigating the current Saga state or tracing the sequence of various calls within the Saga helps to understand the application\u2019s behaviour and performance. Tracing, monitoring and logging microservices also represents one of the challenges within a MSA [ 1 , 6 ]. Therefore, the following criteria deal with the different possibilities the technologies offer concerning these areas. The used criteria originate from the evaluation done by D\u00fcrr et al. [3, p. 79 f.] . Runtime state Listing the different ways the technology provides information about the current state of an ongoing Saga. An example would be a UI that visualizes the different transactions of a Saga and which one is currently being executed. Another option could be the logs of a service or information stored within a database. Orchestrator metrics Services often publish various metrics like the number of started Sagas or compensated ones. These metrics can then be used to configure alerts or draw conclusions about the system\u2019s load and performance. This criterion describes the various metrics the technology provides and which service publishes them. Tracing Determining whether the technology allows activating distributed tracing easily, for example, by offering the integration of systems like Zipkin 2 or OpenTracing 3 rather than manually implementing it. Logging This criterion describes if and which service logs information about the Saga execution. In addition, information that is possible to retrieve from these logs can be mentioned. Analyzing logs can help with troubleshooting or determining the current Saga state. References [1] N. Alshuqayran, N. Ali, and R. Evans, \"A Systematic Mapping Study in Microservice Architecture.\" IEEE Computer Society, 2016, pp. 44\u201351. [Online]. Available: https://dx.doi.org/10.1109/SOCA.2016.15 [2] S. Newman, Building Microservices \u2013 Designing Fine\u2013Grained Systems, 1st ed. O\u2019Reilly Media, Inc., 2015, ISBN: 9781491950357. [3] K. D\u00fcrr, R. Lichtenth\u00e4ler, and G. Wirtz, \"An Evaluation of Saga Pattern Implementation Technologies,\" in Proceedings of the 13th European Workshop on Services and their Composition (ZEUS 2021), Bamberg, Germany, February 25\u201326, 2021, ser. CEUR Workshop Proceedings, vol. 2839. CEUR-WS.org, 2021, pp. 74\u201382. [Online]. Available: http://ceur-ws.org/Vol-2839/paper12.pdf [4] D. Cruz, T. Wieland, and A. Ziegler, \"Evaluation Criteria for Free/Open Source Software Products Based on Project Analysis,\" Software Process: Improvement and Practice, vol. 11, no. 2, pp. 107\u2013122, 2006. [Online]. Available: https://doi.org/10.1002/spip.257 [5] J. P. Confino and P. A. Laplante, \"An Open Source Software Evaluation Model,\" Int. J. Strateg. Inf. Technol. Appl., vol. 1, no. 1, pp. 60\u201377, 2010. [Online]. Available: https://doi.org/10.4018/jsita.2010101505 [6] T. Cerny, M. J. Donahoo, and M. Trnka, \"Contextual Understanding of Microservice Architecture: Current and Future Directions,\" ACM SIGAPP Applied Computing Review, vol. 17, no. 4, pp. 29\u201345, 2018. [Online]. Available: https://dx.doi.org/10.1145/3183628.3183631 [7] O. Zimmermann, \"Microservices Tenets,\" Computer Science \u2013 Research and Development, vol. 32, no. 3\u20134, pp. 301\u2013310, 2016. [Online]. Available: https://dx.doi.org/10.1007/s00450-016-0337-0 https://iso25000.com/index.php/en/iso-25000-standards/iso-25010?start=0 , last accessed 2021-07-06 \u21a9 https://zipkin.io/ , last accessed 2021-07-09 \u21a9 https://opentracing.io/ , last accessed 2021-06-06 \u21a9","title":"Monitoring"},{"location":"CriteriaCatalog/Monitoring/#evaluation-criteria-catalog","text":"In order to evaluate different technological approaches concerning the Saga pattern, some criteria have to be defined against which the evaluation can be performed. The following sections consider several areas of interest related to characteristics of microservices and the Saga pattern as well as some quality attributes of the ISO/IEC 25010 Quality Models 1 . For each area, the aspects that an evaluator should examine are explained and described. Some of the described criteria have been taken from the previous paper published by D\u00fcrr et al. [3] . The aim is to create a criteria catalog that can be used to analyze other technologies in this context.","title":" Evaluation Criteria Catalog"},{"location":"CriteriaCatalog/Monitoring/#monitoring","text":"Since a Saga can be a transaction that takes a long time to finish, investigating the current Saga state or tracing the sequence of various calls within the Saga helps to understand the application\u2019s behaviour and performance. Tracing, monitoring and logging microservices also represents one of the challenges within a MSA [ 1 , 6 ]. Therefore, the following criteria deal with the different possibilities the technologies offer concerning these areas. The used criteria originate from the evaluation done by D\u00fcrr et al. [3, p. 79 f.] .","title":"Monitoring"},{"location":"CriteriaCatalog/Monitoring/#runtime-state","text":"Listing the different ways the technology provides information about the current state of an ongoing Saga. An example would be a UI that visualizes the different transactions of a Saga and which one is currently being executed. Another option could be the logs of a service or information stored within a database.","title":"Runtime state"},{"location":"CriteriaCatalog/Monitoring/#orchestrator-metrics","text":"Services often publish various metrics like the number of started Sagas or compensated ones. These metrics can then be used to configure alerts or draw conclusions about the system\u2019s load and performance. This criterion describes the various metrics the technology provides and which service publishes them.","title":"Orchestrator metrics"},{"location":"CriteriaCatalog/Monitoring/#tracing","text":"Determining whether the technology allows activating distributed tracing easily, for example, by offering the integration of systems like Zipkin 2 or OpenTracing 3 rather than manually implementing it.","title":"Tracing"},{"location":"CriteriaCatalog/Monitoring/#logging","text":"This criterion describes if and which service logs information about the Saga execution. In addition, information that is possible to retrieve from these logs can be mentioned. Analyzing logs can help with troubleshooting or determining the current Saga state.","title":"Logging"},{"location":"CriteriaCatalog/Monitoring/#references","text":"[1] N. Alshuqayran, N. Ali, and R. Evans, \"A Systematic Mapping Study in Microservice Architecture.\" IEEE Computer Society, 2016, pp. 44\u201351. [Online]. Available: https://dx.doi.org/10.1109/SOCA.2016.15 [2] S. Newman, Building Microservices \u2013 Designing Fine\u2013Grained Systems, 1st ed. O\u2019Reilly Media, Inc., 2015, ISBN: 9781491950357. [3] K. D\u00fcrr, R. Lichtenth\u00e4ler, and G. Wirtz, \"An Evaluation of Saga Pattern Implementation Technologies,\" in Proceedings of the 13th European Workshop on Services and their Composition (ZEUS 2021), Bamberg, Germany, February 25\u201326, 2021, ser. CEUR Workshop Proceedings, vol. 2839. CEUR-WS.org, 2021, pp. 74\u201382. [Online]. Available: http://ceur-ws.org/Vol-2839/paper12.pdf [4] D. Cruz, T. Wieland, and A. Ziegler, \"Evaluation Criteria for Free/Open Source Software Products Based on Project Analysis,\" Software Process: Improvement and Practice, vol. 11, no. 2, pp. 107\u2013122, 2006. [Online]. Available: https://doi.org/10.1002/spip.257 [5] J. P. Confino and P. A. Laplante, \"An Open Source Software Evaluation Model,\" Int. J. Strateg. Inf. Technol. Appl., vol. 1, no. 1, pp. 60\u201377, 2010. [Online]. Available: https://doi.org/10.4018/jsita.2010101505 [6] T. Cerny, M. J. Donahoo, and M. Trnka, \"Contextual Understanding of Microservice Architecture: Current and Future Directions,\" ACM SIGAPP Applied Computing Review, vol. 17, no. 4, pp. 29\u201345, 2018. [Online]. Available: https://dx.doi.org/10.1145/3183628.3183631 [7] O. Zimmermann, \"Microservices Tenets,\" Computer Science \u2013 Research and Development, vol. 32, no. 3\u20134, pp. 301\u2013310, 2016. [Online]. Available: https://dx.doi.org/10.1007/s00450-016-0337-0 https://iso25000.com/index.php/en/iso-25000-standards/iso-25010?start=0 , last accessed 2021-07-06 \u21a9 https://zipkin.io/ , last accessed 2021-07-09 \u21a9 https://opentracing.io/ , last accessed 2021-06-06 \u21a9","title":"References"},{"location":"CriteriaCatalog/OSS_Characteristics/","text":"Evaluation Criteria Catalog In order to evaluate different technological approaches concerning the Saga pattern, some criteria have to be defined against which the evaluation can be performed. The following sections consider several areas of interest related to characteristics of microservices and the Saga pattern as well as some quality attributes of the ISO/IEC 25010 Quality Models 1 . For each area, the aspects that an evaluator should examine are explained and described. Some of the described criteria have been taken from the previous paper published by D\u00fcrr et al. [3] . The aim is to create a criteria catalog that can be used to analyze other technologies in this context. Open-Source Software Characteristics OSS characteristics, such as who provides the technology or under which license it is offered, can also be relevant aspects to consider before selecting a technology. If the technology is mainly implemented by a well\u2013known company and a big community supports it, this can imply a certain quality and reliability. Additionally, the company, the project\u2019s circumstances and its community influence the product\u2019s present and anticipated future [4, p. 108] . However, some OSS characteristics have to be treated with caution as they may be subject to different interpretations, like repository stars, or since no generally accepted metrics exist, for example regarding documentation [5, p. 70] . Provider The organization or person that creates and provides the respective technology. License type The OSS license type under which the implementation is released. The license type may introduce some restrictions which can be especially relevant for commercial usage. Repository stars The number of stars that the respective repository currently has. This criterion may indicate the technology\u2019s popularity. However, since the significance of such a star is not certain, it is not possible to use this as a reliable metric. Contributor count The number of people the repository lists as contributors. Fork count The number of forks the repository currently has. Forking a repository means creating a copy of it to another users account. When editing content in the forked repository, it does not introduce changes to the parent repository 2 . Support Examining the kind of community and/or commercial support that is offered for this technology. Such options can be discussion forums, the possibility to document issues or enterprise support like priority hotfixes. Documentation Comprehensive and up\u2013to\u2013date documentation is essential when using OSS , especially if no support is available. Therefore, this criterion assesses if documentation on the use of the technology exists and whether it is up\u2013to\u2013date. Such documentation can be, for example, a website or a readme file in the repository. References [1] N. Alshuqayran, N. Ali, and R. Evans, \"A Systematic Mapping Study in Microservice Architecture.\" IEEE Computer Society, 2016, pp. 44\u201351. [Online]. Available: https://dx.doi.org/10.1109/SOCA.2016.15 [2] S. Newman, Building Microservices \u2013 Designing Fine\u2013Grained Systems, 1st ed. O\u2019Reilly Media, Inc., 2015, ISBN: 9781491950357. [3] K. D\u00fcrr, R. Lichtenth\u00e4ler, and G. Wirtz, \"An Evaluation of Saga Pattern Implementation Technologies,\" in Proceedings of the 13th European Workshop on Services and their Composition (ZEUS 2021), Bamberg, Germany, February 25\u201326, 2021, ser. CEUR Workshop Proceedings, vol. 2839. CEUR-WS.org, 2021, pp. 74\u201382. [Online]. Available: http://ceur-ws.org/Vol-2839/paper12.pdf [4] D. Cruz, T. Wieland, and A. Ziegler, \"Evaluation Criteria for Free/Open Source Software Products Based on Project Analysis,\" Software Process: Improvement and Practice, vol. 11, no. 2, pp. 107\u2013122, 2006. [Online]. Available: https://doi.org/10.1002/spip.257 [5] J. P. Confino and P. A. Laplante, \"An Open Source Software Evaluation Model,\" Int. J. Strateg. Inf. Technol. Appl., vol. 1, no. 1, pp. 60\u201377, 2010. [Online]. Available: https://doi.org/10.4018/jsita.2010101505 [6] T. Cerny, M. J. Donahoo, and M. Trnka, \"Contextual Understanding of Microservice Architecture: Current and Future Directions,\" ACM SIGAPP Applied Computing Review, vol. 17, no. 4, pp. 29\u201345, 2018. [Online]. Available: https://dx.doi.org/10.1145/3183628.3183631 [7] O. Zimmermann, \"Microservices Tenets,\" Computer Science \u2013 Research and Development, vol. 32, no. 3\u20134, pp. 301\u2013310, 2016. [Online]. Available: https://dx.doi.org/10.1007/s00450-016-0337-0 https://iso25000.com/index.php/en/iso-25000-standards/iso-25010?start=0 , last accessed 2021-07-06 \u21a9 https://docs.github.com/en/get-started/quickstart/fork-a-repo , last accessed: 2021-06-27 \u21a9","title":"OSS Characteristics"},{"location":"CriteriaCatalog/OSS_Characteristics/#evaluation-criteria-catalog","text":"In order to evaluate different technological approaches concerning the Saga pattern, some criteria have to be defined against which the evaluation can be performed. The following sections consider several areas of interest related to characteristics of microservices and the Saga pattern as well as some quality attributes of the ISO/IEC 25010 Quality Models 1 . For each area, the aspects that an evaluator should examine are explained and described. Some of the described criteria have been taken from the previous paper published by D\u00fcrr et al. [3] . The aim is to create a criteria catalog that can be used to analyze other technologies in this context.","title":" Evaluation Criteria Catalog"},{"location":"CriteriaCatalog/OSS_Characteristics/#open-source-software-characteristics","text":"OSS characteristics, such as who provides the technology or under which license it is offered, can also be relevant aspects to consider before selecting a technology. If the technology is mainly implemented by a well\u2013known company and a big community supports it, this can imply a certain quality and reliability. Additionally, the company, the project\u2019s circumstances and its community influence the product\u2019s present and anticipated future [4, p. 108] . However, some OSS characteristics have to be treated with caution as they may be subject to different interpretations, like repository stars, or since no generally accepted metrics exist, for example regarding documentation [5, p. 70] .","title":"Open-Source Software Characteristics"},{"location":"CriteriaCatalog/OSS_Characteristics/#provider","text":"The organization or person that creates and provides the respective technology.","title":"Provider"},{"location":"CriteriaCatalog/OSS_Characteristics/#license-type","text":"The OSS license type under which the implementation is released. The license type may introduce some restrictions which can be especially relevant for commercial usage.","title":"License type"},{"location":"CriteriaCatalog/OSS_Characteristics/#repository-stars","text":"The number of stars that the respective repository currently has. This criterion may indicate the technology\u2019s popularity. However, since the significance of such a star is not certain, it is not possible to use this as a reliable metric.","title":"Repository stars"},{"location":"CriteriaCatalog/OSS_Characteristics/#contributor-count","text":"The number of people the repository lists as contributors.","title":"Contributor count"},{"location":"CriteriaCatalog/OSS_Characteristics/#fork-count","text":"The number of forks the repository currently has. Forking a repository means creating a copy of it to another users account. When editing content in the forked repository, it does not introduce changes to the parent repository 2 .","title":"Fork count"},{"location":"CriteriaCatalog/OSS_Characteristics/#support","text":"Examining the kind of community and/or commercial support that is offered for this technology. Such options can be discussion forums, the possibility to document issues or enterprise support like priority hotfixes.","title":"Support"},{"location":"CriteriaCatalog/OSS_Characteristics/#documentation","text":"Comprehensive and up\u2013to\u2013date documentation is essential when using OSS , especially if no support is available. Therefore, this criterion assesses if documentation on the use of the technology exists and whether it is up\u2013to\u2013date. Such documentation can be, for example, a website or a readme file in the repository.","title":"Documentation"},{"location":"CriteriaCatalog/OSS_Characteristics/#references","text":"[1] N. Alshuqayran, N. Ali, and R. Evans, \"A Systematic Mapping Study in Microservice Architecture.\" IEEE Computer Society, 2016, pp. 44\u201351. [Online]. Available: https://dx.doi.org/10.1109/SOCA.2016.15 [2] S. Newman, Building Microservices \u2013 Designing Fine\u2013Grained Systems, 1st ed. O\u2019Reilly Media, Inc., 2015, ISBN: 9781491950357. [3] K. D\u00fcrr, R. Lichtenth\u00e4ler, and G. Wirtz, \"An Evaluation of Saga Pattern Implementation Technologies,\" in Proceedings of the 13th European Workshop on Services and their Composition (ZEUS 2021), Bamberg, Germany, February 25\u201326, 2021, ser. CEUR Workshop Proceedings, vol. 2839. CEUR-WS.org, 2021, pp. 74\u201382. [Online]. Available: http://ceur-ws.org/Vol-2839/paper12.pdf [4] D. Cruz, T. Wieland, and A. Ziegler, \"Evaluation Criteria for Free/Open Source Software Products Based on Project Analysis,\" Software Process: Improvement and Practice, vol. 11, no. 2, pp. 107\u2013122, 2006. [Online]. Available: https://doi.org/10.1002/spip.257 [5] J. P. Confino and P. A. Laplante, \"An Open Source Software Evaluation Model,\" Int. J. Strateg. Inf. Technol. Appl., vol. 1, no. 1, pp. 60\u201377, 2010. [Online]. Available: https://doi.org/10.4018/jsita.2010101505 [6] T. Cerny, M. J. Donahoo, and M. Trnka, \"Contextual Understanding of Microservice Architecture: Current and Future Directions,\" ACM SIGAPP Applied Computing Review, vol. 17, no. 4, pp. 29\u201345, 2018. [Online]. Available: https://dx.doi.org/10.1145/3183628.3183631 [7] O. Zimmermann, \"Microservices Tenets,\" Computer Science \u2013 Research and Development, vol. 32, no. 3\u20134, pp. 301\u2013310, 2016. [Online]. Available: https://dx.doi.org/10.1007/s00450-016-0337-0 https://iso25000.com/index.php/en/iso-25000-standards/iso-25010?start=0 , last accessed 2021-07-06 \u21a9 https://docs.github.com/en/get-started/quickstart/fork-a-repo , last accessed: 2021-06-27 \u21a9","title":"References"},{"location":"CriteriaCatalog/Portability/","text":"Evaluation Criteria Catalog In order to evaluate different technological approaches concerning the Saga pattern, some criteria have to be defined against which the evaluation can be performed. The following sections consider several areas of interest related to characteristics of microservices and the Saga pattern as well as some quality attributes of the ISO/IEC 25010 Quality Models 1 . For each area, the aspects that an evaluator should examine are explained and described. Some of the described criteria have been taken from the previous paper published by D\u00fcrr et al. [3] . The aim is to create a criteria catalog that can be used to analyze other technologies in this context. Portability Another important aspect is whether and to what extent the implementation technology supports deploying the implementation to different platforms and environments. Popular options here are nowadays containers or deploying the application directly to the cloud. Therefore, the following criteria consider the support of these. Containerization This criterion evaluates if support is given for containerizing the application, for example using Docker 4 , DockerCompose 5 or Kubernetes 6 . This can include providing Docker Images on DockerHub 7 for required infrastructure services or sample Docker or Kubernetes files. Cloud deployment Investigating whether extra support is provided to deploy the application to one or more specific cloud providers. For example, such support could be documentation or a guide explaining how to deploy the application to a specific cloud. References [1] N. Alshuqayran, N. Ali, and R. Evans, \"A Systematic Mapping Study in Microservice Architecture.\" IEEE Computer Society, 2016, pp. 44\u201351. [Online]. Available: https://dx.doi.org/10.1109/SOCA.2016.15 [2] S. Newman, Building Microservices \u2013 Designing Fine\u2013Grained Systems, 1st ed. O\u2019Reilly Media, Inc., 2015, ISBN: 9781491950357. [3] K. D\u00fcrr, R. Lichtenth\u00e4ler, and G. Wirtz, \"An Evaluation of Saga Pattern Implementation Technologies,\" in Proceedings of the 13th European Workshop on Services and their Composition (ZEUS 2021), Bamberg, Germany, February 25\u201326, 2021, ser. CEUR Workshop Proceedings, vol. 2839. CEUR-WS.org, 2021, pp. 74\u201382. [Online]. Available: http://ceur-ws.org/Vol-2839/paper12.pdf [4] D. Cruz, T. Wieland, and A. Ziegler, \"Evaluation Criteria for Free/Open Source Software Products Based on Project Analysis,\" Software Process: Improvement and Practice, vol. 11, no. 2, pp. 107\u2013122, 2006. [Online]. Available: https://doi.org/10.1002/spip.257 [5] J. P. Confino and P. A. Laplante, \"An Open Source Software Evaluation Model,\" Int. J. Strateg. Inf. Technol. Appl., vol. 1, no. 1, pp. 60\u201377, 2010. [Online]. Available: https://doi.org/10.4018/jsita.2010101505 [6] T. Cerny, M. J. Donahoo, and M. Trnka, \"Contextual Understanding of Microservice Architecture: Current and Future Directions,\" ACM SIGAPP Applied Computing Review, vol. 17, no. 4, pp. 29\u201345, 2018. [Online]. Available: https://dx.doi.org/10.1145/3183628.3183631 [7] O. Zimmermann, \"Microservices Tenets,\" Computer Science \u2013 Research and Development, vol. 32, no. 3\u20134, pp. 301\u2013310, 2016. [Online]. Available: https://dx.doi.org/10.1007/s00450-016-0337-0 https://iso25000.com/index.php/en/iso-25000-standards/iso-25010?start=0 , last accessed 2021-07-06 \u21a9 https://zipkin.io/ , last accessed 2021-07-09 \u21a9 https://opentracing.io/ , last accessed 2021-06-06 \u21a9 https://www.docker.com/ , last accessed: 2021-06-28 \u21a9 https://docs.docker.com/compose/ , last accessed: 2021-06-28 \u21a9 https://kubernetes.io/ , last accessed: 2021-06-28 \u21a9 https://hub.docker.com/ , last accessed: 2021-06-28 \u21a9 https://docs.github.com/en/get-started/quickstart/fork-a-repo , last accessed: 2021-06-27 \u21a9","title":"Portability"},{"location":"CriteriaCatalog/Portability/#evaluation-criteria-catalog","text":"In order to evaluate different technological approaches concerning the Saga pattern, some criteria have to be defined against which the evaluation can be performed. The following sections consider several areas of interest related to characteristics of microservices and the Saga pattern as well as some quality attributes of the ISO/IEC 25010 Quality Models 1 . For each area, the aspects that an evaluator should examine are explained and described. Some of the described criteria have been taken from the previous paper published by D\u00fcrr et al. [3] . The aim is to create a criteria catalog that can be used to analyze other technologies in this context.","title":" Evaluation Criteria Catalog"},{"location":"CriteriaCatalog/Portability/#portability","text":"Another important aspect is whether and to what extent the implementation technology supports deploying the implementation to different platforms and environments. Popular options here are nowadays containers or deploying the application directly to the cloud. Therefore, the following criteria consider the support of these.","title":"Portability"},{"location":"CriteriaCatalog/Portability/#containerization","text":"This criterion evaluates if support is given for containerizing the application, for example using Docker 4 , DockerCompose 5 or Kubernetes 6 . This can include providing Docker Images on DockerHub 7 for required infrastructure services or sample Docker or Kubernetes files.","title":"Containerization"},{"location":"CriteriaCatalog/Portability/#cloud-deployment","text":"Investigating whether extra support is provided to deploy the application to one or more specific cloud providers. For example, such support could be documentation or a guide explaining how to deploy the application to a specific cloud.","title":"Cloud deployment"},{"location":"CriteriaCatalog/Portability/#references","text":"[1] N. Alshuqayran, N. Ali, and R. Evans, \"A Systematic Mapping Study in Microservice Architecture.\" IEEE Computer Society, 2016, pp. 44\u201351. [Online]. Available: https://dx.doi.org/10.1109/SOCA.2016.15 [2] S. Newman, Building Microservices \u2013 Designing Fine\u2013Grained Systems, 1st ed. O\u2019Reilly Media, Inc., 2015, ISBN: 9781491950357. [3] K. D\u00fcrr, R. Lichtenth\u00e4ler, and G. Wirtz, \"An Evaluation of Saga Pattern Implementation Technologies,\" in Proceedings of the 13th European Workshop on Services and their Composition (ZEUS 2021), Bamberg, Germany, February 25\u201326, 2021, ser. CEUR Workshop Proceedings, vol. 2839. CEUR-WS.org, 2021, pp. 74\u201382. [Online]. Available: http://ceur-ws.org/Vol-2839/paper12.pdf [4] D. Cruz, T. Wieland, and A. Ziegler, \"Evaluation Criteria for Free/Open Source Software Products Based on Project Analysis,\" Software Process: Improvement and Practice, vol. 11, no. 2, pp. 107\u2013122, 2006. [Online]. Available: https://doi.org/10.1002/spip.257 [5] J. P. Confino and P. A. Laplante, \"An Open Source Software Evaluation Model,\" Int. J. Strateg. Inf. Technol. Appl., vol. 1, no. 1, pp. 60\u201377, 2010. [Online]. Available: https://doi.org/10.4018/jsita.2010101505 [6] T. Cerny, M. J. Donahoo, and M. Trnka, \"Contextual Understanding of Microservice Architecture: Current and Future Directions,\" ACM SIGAPP Applied Computing Review, vol. 17, no. 4, pp. 29\u201345, 2018. [Online]. Available: https://dx.doi.org/10.1145/3183628.3183631 [7] O. Zimmermann, \"Microservices Tenets,\" Computer Science \u2013 Research and Development, vol. 32, no. 3\u20134, pp. 301\u2013310, 2016. [Online]. Available: https://dx.doi.org/10.1007/s00450-016-0337-0 https://iso25000.com/index.php/en/iso-25000-standards/iso-25010?start=0 , last accessed 2021-07-06 \u21a9 https://zipkin.io/ , last accessed 2021-07-09 \u21a9 https://opentracing.io/ , last accessed 2021-06-06 \u21a9 https://www.docker.com/ , last accessed: 2021-06-28 \u21a9 https://docs.docker.com/compose/ , last accessed: 2021-06-28 \u21a9 https://kubernetes.io/ , last accessed: 2021-06-28 \u21a9 https://hub.docker.com/ , last accessed: 2021-06-28 \u21a9 https://docs.github.com/en/get-started/quickstart/fork-a-repo , last accessed: 2021-06-27 \u21a9","title":"References"},{"location":"CriteriaCatalog/Security/","text":"Evaluation Criteria Catalog In order to evaluate different technological approaches concerning the Saga pattern, some criteria have to be defined against which the evaluation can be performed. The following sections consider several areas of interest related to characteristics of microservices and the Saga pattern as well as some quality attributes of the ISO/IEC 25010 Quality Models 1 . For each area, the aspects that an evaluator should examine are explained and described. Some of the described criteria have been taken from the previous paper published by D\u00fcrr et al. [3] . The aim is to create a criteria catalog that can be used to analyze other technologies in this context. Security Considering Security aspects is also important when implementing the Saga pattern. It might not be desirable that every service has the ability to start a Saga or that services communicate in a non\u2013encrypted way. Therefore, ensuring and configuring communication security is important, especially since external services might also be included in a Saga. Encrypted communication This criterion analyzes if the communication between the orchestrator and participants is encrypted and, if not, whether the developer can easily activate it. For example, a manual change of the communication mechanism from HTTP to HTTPS . Authentication support Investigating whether the technology offers the possibility that services have to authenticate themselves to the orchestrator, for example, in order to be allowed to participate in a Saga. Authorization support This criterion extends the Authentication support criterion by checking if there also exists the option to grant or restrict access to certain functions or resources. An example could be that only one specific service is allowed to start Sagas, whereas the others can only participate in it. References [1] N. Alshuqayran, N. Ali, and R. Evans, \"A Systematic Mapping Study in Microservice Architecture.\" IEEE Computer Society, 2016, pp. 44\u201351. [Online]. Available: https://dx.doi.org/10.1109/SOCA.2016.15 [2] S. Newman, Building Microservices \u2013 Designing Fine\u2013Grained Systems, 1st ed. O\u2019Reilly Media, Inc., 2015, ISBN: 9781491950357. [3] K. D\u00fcrr, R. Lichtenth\u00e4ler, and G. Wirtz, \"An Evaluation of Saga Pattern Implementation Technologies,\" in Proceedings of the 13th European Workshop on Services and their Composition (ZEUS 2021), Bamberg, Germany, February 25\u201326, 2021, ser. CEUR Workshop Proceedings, vol. 2839. CEUR-WS.org, 2021, pp. 74\u201382. [Online]. Available: http://ceur-ws.org/Vol-2839/paper12.pdf [4] D. Cruz, T. Wieland, and A. Ziegler, \"Evaluation Criteria for Free/Open Source Software Products Based on Project Analysis,\" Software Process: Improvement and Practice, vol. 11, no. 2, pp. 107\u2013122, 2006. [Online]. Available: https://doi.org/10.1002/spip.257 [5] J. P. Confino and P. A. Laplante, \"An Open Source Software Evaluation Model,\" Int. J. Strateg. Inf. Technol. Appl., vol. 1, no. 1, pp. 60\u201377, 2010. [Online]. Available: https://doi.org/10.4018/jsita.2010101505 [6] T. Cerny, M. J. Donahoo, and M. Trnka, \"Contextual Understanding of Microservice Architecture: Current and Future Directions,\" ACM SIGAPP Applied Computing Review, vol. 17, no. 4, pp. 29\u201345, 2018. [Online]. Available: https://dx.doi.org/10.1145/3183628.3183631 [7] O. Zimmermann, \"Microservices Tenets,\" Computer Science \u2013 Research and Development, vol. 32, no. 3\u20134, pp. 301\u2013310, 2016. [Online]. Available: https://dx.doi.org/10.1007/s00450-016-0337-0 https://iso25000.com/index.php/en/iso-25000-standards/iso-25010?start=0 , last accessed 2021-07-06 \u21a9","title":"Security"},{"location":"CriteriaCatalog/Security/#evaluation-criteria-catalog","text":"In order to evaluate different technological approaches concerning the Saga pattern, some criteria have to be defined against which the evaluation can be performed. The following sections consider several areas of interest related to characteristics of microservices and the Saga pattern as well as some quality attributes of the ISO/IEC 25010 Quality Models 1 . For each area, the aspects that an evaluator should examine are explained and described. Some of the described criteria have been taken from the previous paper published by D\u00fcrr et al. [3] . The aim is to create a criteria catalog that can be used to analyze other technologies in this context.","title":" Evaluation Criteria Catalog"},{"location":"CriteriaCatalog/Security/#security","text":"Considering Security aspects is also important when implementing the Saga pattern. It might not be desirable that every service has the ability to start a Saga or that services communicate in a non\u2013encrypted way. Therefore, ensuring and configuring communication security is important, especially since external services might also be included in a Saga.","title":"Security"},{"location":"CriteriaCatalog/Security/#encrypted-communication","text":"This criterion analyzes if the communication between the orchestrator and participants is encrypted and, if not, whether the developer can easily activate it. For example, a manual change of the communication mechanism from HTTP to HTTPS .","title":"Encrypted communication"},{"location":"CriteriaCatalog/Security/#authentication-support","text":"Investigating whether the technology offers the possibility that services have to authenticate themselves to the orchestrator, for example, in order to be allowed to participate in a Saga.","title":"Authentication support"},{"location":"CriteriaCatalog/Security/#authorization-support","text":"This criterion extends the Authentication support criterion by checking if there also exists the option to grant or restrict access to certain functions or resources. An example could be that only one specific service is allowed to start Sagas, whereas the others can only participate in it.","title":"Authorization support"},{"location":"CriteriaCatalog/Security/#references","text":"[1] N. Alshuqayran, N. Ali, and R. Evans, \"A Systematic Mapping Study in Microservice Architecture.\" IEEE Computer Society, 2016, pp. 44\u201351. [Online]. Available: https://dx.doi.org/10.1109/SOCA.2016.15 [2] S. Newman, Building Microservices \u2013 Designing Fine\u2013Grained Systems, 1st ed. O\u2019Reilly Media, Inc., 2015, ISBN: 9781491950357. [3] K. D\u00fcrr, R. Lichtenth\u00e4ler, and G. Wirtz, \"An Evaluation of Saga Pattern Implementation Technologies,\" in Proceedings of the 13th European Workshop on Services and their Composition (ZEUS 2021), Bamberg, Germany, February 25\u201326, 2021, ser. CEUR Workshop Proceedings, vol. 2839. CEUR-WS.org, 2021, pp. 74\u201382. [Online]. Available: http://ceur-ws.org/Vol-2839/paper12.pdf [4] D. Cruz, T. Wieland, and A. Ziegler, \"Evaluation Criteria for Free/Open Source Software Products Based on Project Analysis,\" Software Process: Improvement and Practice, vol. 11, no. 2, pp. 107\u2013122, 2006. [Online]. Available: https://doi.org/10.1002/spip.257 [5] J. P. Confino and P. A. Laplante, \"An Open Source Software Evaluation Model,\" Int. J. Strateg. Inf. Technol. Appl., vol. 1, no. 1, pp. 60\u201377, 2010. [Online]. Available: https://doi.org/10.4018/jsita.2010101505 [6] T. Cerny, M. J. Donahoo, and M. Trnka, \"Contextual Understanding of Microservice Architecture: Current and Future Directions,\" ACM SIGAPP Applied Computing Review, vol. 17, no. 4, pp. 29\u201345, 2018. [Online]. Available: https://dx.doi.org/10.1145/3183628.3183631 [7] O. Zimmermann, \"Microservices Tenets,\" Computer Science \u2013 Research and Development, vol. 32, no. 3\u20134, pp. 301\u2013310, 2016. [Online]. Available: https://dx.doi.org/10.1007/s00450-016-0337-0 https://iso25000.com/index.php/en/iso-25000-standards/iso-25010?start=0 , last accessed 2021-07-06 \u21a9","title":"References"},{"location":"CriteriaCatalog/Testability/","text":"Evaluation Criteria Catalog In order to evaluate different technological approaches concerning the Saga pattern, some criteria have to be defined against which the evaluation can be performed. The following sections consider several areas of interest related to characteristics of microservices and the Saga pattern as well as some quality attributes of the ISO/IEC 25010 Quality Models 1 . For each area, the aspects that an evaluator should examine are explained and described. Some of the described criteria have been taken from the previous paper published by D\u00fcrr et al. [3] . The aim is to create a criteria catalog that can be used to analyze other technologies in this context. Testability Automatic testing helps to ensure and maintain software quality. Since Sagas are useful for implementing complex business workflows, being able to test Saga sequences improves quality, especially when adding new steps or participants. In\u2013house test framework Examine whether the technology itself provides additional support for testing the Saga\u2013related implementations. An example could be a provided DSL that helps testing Saga\u2013related aspects of the technology. Unit test Saga definition To ensure that the Saga sequence is executed as expected, it is beneficial to test the definition automatically. Even more so, when the definition can be tested in isolation, so without having to really run the Saga with all its dependencies. Unit test Saga participant Investigating if the behaviour of a Saga participant can be tested in isolation, again without running the entire Saga. Saga integration test After analyzing the possibilities to test Saga\u2013related implementations in isolation, the next step is to verify the interaction between the included components. Therefore, this criterion investigates if it is possible to test the execution of the entire Saga automatically. References [1] N. Alshuqayran, N. Ali, and R. Evans, \"A Systematic Mapping Study in Microservice Architecture.\" IEEE Computer Society, 2016, pp. 44\u201351. [Online]. Available: https://dx.doi.org/10.1109/SOCA.2016.15 [2] S. Newman, Building Microservices \u2013 Designing Fine\u2013Grained Systems, 1st ed. O\u2019Reilly Media, Inc., 2015, ISBN: 9781491950357. [3] K. D\u00fcrr, R. Lichtenth\u00e4ler, and G. Wirtz, \"An Evaluation of Saga Pattern Implementation Technologies,\" in Proceedings of the 13th European Workshop on Services and their Composition (ZEUS 2021), Bamberg, Germany, February 25\u201326, 2021, ser. CEUR Workshop Proceedings, vol. 2839. CEUR-WS.org, 2021, pp. 74\u201382. [Online]. Available: http://ceur-ws.org/Vol-2839/paper12.pdf [4] D. Cruz, T. Wieland, and A. Ziegler, \"Evaluation Criteria for Free/Open Source Software Products Based on Project Analysis,\" Software Process: Improvement and Practice, vol. 11, no. 2, pp. 107\u2013122, 2006. [Online]. Available: https://doi.org/10.1002/spip.257 [5] J. P. Confino and P. A. Laplante, \"An Open Source Software Evaluation Model,\" Int. J. Strateg. Inf. Technol. Appl., vol. 1, no. 1, pp. 60\u201377, 2010. [Online]. Available: https://doi.org/10.4018/jsita.2010101505 [6] T. Cerny, M. J. Donahoo, and M. Trnka, \"Contextual Understanding of Microservice Architecture: Current and Future Directions,\" ACM SIGAPP Applied Computing Review, vol. 17, no. 4, pp. 29\u201345, 2018. [Online]. Available: https://dx.doi.org/10.1145/3183628.3183631 [7] O. Zimmermann, \"Microservices Tenets,\" Computer Science \u2013 Research and Development, vol. 32, no. 3\u20134, pp. 301\u2013310, 2016. [Online]. Available: https://dx.doi.org/10.1007/s00450-016-0337-0 https://iso25000.com/index.php/en/iso-25000-standards/iso-25010?start=0 , last accessed 2021-07-06 \u21a9","title":"Testability"},{"location":"CriteriaCatalog/Testability/#evaluation-criteria-catalog","text":"In order to evaluate different technological approaches concerning the Saga pattern, some criteria have to be defined against which the evaluation can be performed. The following sections consider several areas of interest related to characteristics of microservices and the Saga pattern as well as some quality attributes of the ISO/IEC 25010 Quality Models 1 . For each area, the aspects that an evaluator should examine are explained and described. Some of the described criteria have been taken from the previous paper published by D\u00fcrr et al. [3] . The aim is to create a criteria catalog that can be used to analyze other technologies in this context.","title":" Evaluation Criteria Catalog"},{"location":"CriteriaCatalog/Testability/#testability","text":"Automatic testing helps to ensure and maintain software quality. Since Sagas are useful for implementing complex business workflows, being able to test Saga sequences improves quality, especially when adding new steps or participants.","title":"Testability"},{"location":"CriteriaCatalog/Testability/#inhouse-test-framework","text":"Examine whether the technology itself provides additional support for testing the Saga\u2013related implementations. An example could be a provided DSL that helps testing Saga\u2013related aspects of the technology.","title":"In\u2013house test framework"},{"location":"CriteriaCatalog/Testability/#unit-test-saga-definition","text":"To ensure that the Saga sequence is executed as expected, it is beneficial to test the definition automatically. Even more so, when the definition can be tested in isolation, so without having to really run the Saga with all its dependencies.","title":"Unit test Saga definition"},{"location":"CriteriaCatalog/Testability/#unit-test-saga-participant","text":"Investigating if the behaviour of a Saga participant can be tested in isolation, again without running the entire Saga.","title":"Unit test Saga participant"},{"location":"CriteriaCatalog/Testability/#saga-integration-test","text":"After analyzing the possibilities to test Saga\u2013related implementations in isolation, the next step is to verify the interaction between the included components. Therefore, this criterion investigates if it is possible to test the execution of the entire Saga automatically.","title":"Saga integration test"},{"location":"CriteriaCatalog/Testability/#references","text":"[1] N. Alshuqayran, N. Ali, and R. Evans, \"A Systematic Mapping Study in Microservice Architecture.\" IEEE Computer Society, 2016, pp. 44\u201351. [Online]. Available: https://dx.doi.org/10.1109/SOCA.2016.15 [2] S. Newman, Building Microservices \u2013 Designing Fine\u2013Grained Systems, 1st ed. O\u2019Reilly Media, Inc., 2015, ISBN: 9781491950357. [3] K. D\u00fcrr, R. Lichtenth\u00e4ler, and G. Wirtz, \"An Evaluation of Saga Pattern Implementation Technologies,\" in Proceedings of the 13th European Workshop on Services and their Composition (ZEUS 2021), Bamberg, Germany, February 25\u201326, 2021, ser. CEUR Workshop Proceedings, vol. 2839. CEUR-WS.org, 2021, pp. 74\u201382. [Online]. Available: http://ceur-ws.org/Vol-2839/paper12.pdf [4] D. Cruz, T. Wieland, and A. Ziegler, \"Evaluation Criteria for Free/Open Source Software Products Based on Project Analysis,\" Software Process: Improvement and Practice, vol. 11, no. 2, pp. 107\u2013122, 2006. [Online]. Available: https://doi.org/10.1002/spip.257 [5] J. P. Confino and P. A. Laplante, \"An Open Source Software Evaluation Model,\" Int. J. Strateg. Inf. Technol. Appl., vol. 1, no. 1, pp. 60\u201377, 2010. [Online]. Available: https://doi.org/10.4018/jsita.2010101505 [6] T. Cerny, M. J. Donahoo, and M. Trnka, \"Contextual Understanding of Microservice Architecture: Current and Future Directions,\" ACM SIGAPP Applied Computing Review, vol. 17, no. 4, pp. 29\u201345, 2018. [Online]. Available: https://dx.doi.org/10.1145/3183628.3183631 [7] O. Zimmermann, \"Microservices Tenets,\" Computer Science \u2013 Research and Development, vol. 32, no. 3\u20134, pp. 301\u2013310, 2016. [Online]. Available: https://dx.doi.org/10.1007/s00450-016-0337-0 https://iso25000.com/index.php/en/iso-25000-standards/iso-25010?start=0 , last accessed 2021-07-06 \u21a9","title":"References"},{"location":"EvaluationSummary/","text":"Evaluation Summary Summarizing the findings and observations of the evaluation, the following overview for the four implementation technologies emerges. The individual tables includes all defined criteria of the formerly developed Criteria Catalog . Table of Contents General Saga Characteristics Monitoring Expandability Fault Tolerance Security Testability Portability OSS Characteristics","title":"Evaluation Summary"},{"location":"EvaluationSummary/#evaluation-summary","text":"Summarizing the findings and observations of the evaluation, the following overview for the four implementation technologies emerges. The individual tables includes all defined criteria of the formerly developed Criteria Catalog .","title":"Evaluation Summary"},{"location":"EvaluationSummary/#table-of-contents","text":"General Saga Characteristics Monitoring Expandability Fault Tolerance Security Testability Portability OSS Characteristics","title":"Table of Contents"},{"location":"EvaluationSummary/ExpandabilityResults/","text":"Evaluation Summary: Expandability The following table shows the results for the criteria defined in Criteria Catalog: Expandability . Criterion Eventuate Tram Netflix Conductor Camunda MicroProfile LRA Terminating/Pausing running Sagas not directly via API / UI via API / UI via API Versioning Sagas \u2714 \u2714 Built-in language support Java Java, Python Java Java Any language for orchestrator \u2714 \u2714 Any language for participant \u2714 \u2714 \u2714","title":"Expandability"},{"location":"EvaluationSummary/ExpandabilityResults/#evaluation-summary-expandability","text":"The following table shows the results for the criteria defined in Criteria Catalog: Expandability . Criterion Eventuate Tram Netflix Conductor Camunda MicroProfile LRA Terminating/Pausing running Sagas not directly via API / UI via API / UI via API Versioning Sagas \u2714 \u2714 Built-in language support Java Java, Python Java Java Any language for orchestrator \u2714 \u2714 Any language for participant \u2714 \u2714 \u2714","title":"Evaluation Summary: Expandability"},{"location":"EvaluationSummary/FaultToleranceResults/","text":"Evaluation Summary: Fault Tolerance The following table shows the results for the criteria defined in Criteria Catalog: Fault Tolerance . Criterion Eventuate Tram Netflix Conductor Camunda MicroProfile LRA Execution timeouts enforced enforced \u2714 Reaction to participant fault unsubscribe retry retry developer's responsibility & compensation Saga continuation trigger after orchestrator crash new Saga instance restart of Conductor server restart of TravelService (developer's responsibility) New Sagas while orchestrator unavailable \u2714 only with buffering Independent compensating transactions \u2714 \u2714 \u2714 Orchestrator reaction to duplicate messages detect & ignore detect & ignore log exception & ignore developer's responsibility, detect & ignore Orchestrator reaction to old messages detect & ignore detect & ignore log exception & ignore eveloper's responsibility, detect & ignore High availability through replication through replication through replication \u2013 Info The MicroProfile LRA specification does not include explicit information on whether it is possible to achieve high availability through methods like replication. Furthermore, the chosen runtime OpenLiberty, which includes the implementation for LRA, is still in a beta state 1 . Therefore, their official documentation does not include information about MicroProfile LRA yet, which also means no information about a highly available system with it. Consequently, further tests would be necessary to be able to make a statement about high availability with MicroProfile LRA. https://openliberty.io/blog/2021/01/27/microprofile-long-running-actions-beta.html , last accessed: 2021-07-15 \u21a9","title":"Fault Tolerance"},{"location":"EvaluationSummary/FaultToleranceResults/#evaluation-summary-fault-tolerance","text":"The following table shows the results for the criteria defined in Criteria Catalog: Fault Tolerance . Criterion Eventuate Tram Netflix Conductor Camunda MicroProfile LRA Execution timeouts enforced enforced \u2714 Reaction to participant fault unsubscribe retry retry developer's responsibility & compensation Saga continuation trigger after orchestrator crash new Saga instance restart of Conductor server restart of TravelService (developer's responsibility) New Sagas while orchestrator unavailable \u2714 only with buffering Independent compensating transactions \u2714 \u2714 \u2714 Orchestrator reaction to duplicate messages detect & ignore detect & ignore log exception & ignore developer's responsibility, detect & ignore Orchestrator reaction to old messages detect & ignore detect & ignore log exception & ignore eveloper's responsibility, detect & ignore High availability through replication through replication through replication \u2013 Info The MicroProfile LRA specification does not include explicit information on whether it is possible to achieve high availability through methods like replication. Furthermore, the chosen runtime OpenLiberty, which includes the implementation for LRA, is still in a beta state 1 . Therefore, their official documentation does not include information about MicroProfile LRA yet, which also means no information about a highly available system with it. Consequently, further tests would be necessary to be able to make a statement about high availability with MicroProfile LRA. https://openliberty.io/blog/2021/01/27/microprofile-long-running-actions-beta.html , last accessed: 2021-07-15 \u21a9","title":"Evaluation Summary: Fault Tolerance"},{"location":"EvaluationSummary/GeneralSagaCharacteristicsResults/","text":"Evaluation Summary: General Saga Characteristics The following table shows the results for the criteria defined in Criteria Catalog: General Saga Characteristics . Criterion Eventuate Tram Netflix Conductor Camunda MicroProfile LRA Saga definition Eventuate DSL JSON / provided clients Modeler / XML / Java DSL Annotations Orchestrating services CDC Service, TravelService Conductor server Camunda Engine in TravelService MicroProfile Coordinator, TravelService Specifying compensating transactions \u2714 \u2714 \u2714 \u2714 Compensation transaction allocation specific transaction entire workflow specific transaction resource class Parallel transaction execution \u2714 \u2714 developer's responsibility Parallel execution configurable \u2714 \u2714 developer's responsibility Participant communication selectable \u2714 \u2714 External compensation trigger not directly via API via API via API Choreographed Sagas \u2714","title":"General Saga Characteristics"},{"location":"EvaluationSummary/GeneralSagaCharacteristicsResults/#evaluation-summary-general-saga-characteristics","text":"The following table shows the results for the criteria defined in Criteria Catalog: General Saga Characteristics . Criterion Eventuate Tram Netflix Conductor Camunda MicroProfile LRA Saga definition Eventuate DSL JSON / provided clients Modeler / XML / Java DSL Annotations Orchestrating services CDC Service, TravelService Conductor server Camunda Engine in TravelService MicroProfile Coordinator, TravelService Specifying compensating transactions \u2714 \u2714 \u2714 \u2714 Compensation transaction allocation specific transaction entire workflow specific transaction resource class Parallel transaction execution \u2714 \u2714 developer's responsibility Parallel execution configurable \u2714 \u2714 developer's responsibility Participant communication selectable \u2714 \u2714 External compensation trigger not directly via API via API via API Choreographed Sagas \u2714","title":"Evaluation Summary: General Saga Characteristics"},{"location":"EvaluationSummary/MonitoringResults/","text":"Evaluation Summary: Monitoring The following table shows the results for the criteria defined in Criteria Catalog: Monitoring . Criterion Eventuate Tram Netflix Conductor Camunda MicroProfile LRA Runtime state of Sagas via database UI visualization UI visualization, database partly via coordinator API Orchestrator metrics from CDC service from Conductor server from embedded Process Engine from embedded Coordinator, TravelService Tracing Zipkin integration not directly supported not directly supported Zipkin & Jaeger integration Logging microservices logs Conductor server logs microservices logs microservices logs","title":"Monitoring"},{"location":"EvaluationSummary/MonitoringResults/#evaluation-summary-monitoring","text":"The following table shows the results for the criteria defined in Criteria Catalog: Monitoring . Criterion Eventuate Tram Netflix Conductor Camunda MicroProfile LRA Runtime state of Sagas via database UI visualization UI visualization, database partly via coordinator API Orchestrator metrics from CDC service from Conductor server from embedded Process Engine from embedded Coordinator, TravelService Tracing Zipkin integration not directly supported not directly supported Zipkin & Jaeger integration Logging microservices logs Conductor server logs microservices logs microservices logs","title":"Evaluation Summary: Monitoring"},{"location":"EvaluationSummary/OSS_CharacteristicsResults/","text":"Evaluation Summary: OSS Characteristics The following table shows the results for the criteria defined in Criteria Catalog: OSS Characteristics . Criterion Eventuate Tram Netflix Conductor Camunda MicroProfile LRA Provider Eventuate Netflix Camunda Eclipse License Type Apache Licence 2.0 Apache Licence 2.0 Apache Licence 2.0 Apache Licence 2.0 Repository stars 1 781 3664 2350 71 Fork count 1 180 approx. 1200 approx. 1000 24 Contributor count 1 2 161 175 18 Support Issue tracking Discussion forum Enterprise support Issue tracking Discussion forum Issue tracking Discussion forum Enterprise support Issue tracking Discussion forum Documentation \u2714 \u2714 \u2714 \u2714 Numbers specific for respective Github repository, as of 2021-11-30 \u21a9 \u21a9 \u21a9","title":"OSS Characteristics"},{"location":"EvaluationSummary/OSS_CharacteristicsResults/#evaluation-summary-oss-characteristics","text":"The following table shows the results for the criteria defined in Criteria Catalog: OSS Characteristics . Criterion Eventuate Tram Netflix Conductor Camunda MicroProfile LRA Provider Eventuate Netflix Camunda Eclipse License Type Apache Licence 2.0 Apache Licence 2.0 Apache Licence 2.0 Apache Licence 2.0 Repository stars 1 781 3664 2350 71 Fork count 1 180 approx. 1200 approx. 1000 24 Contributor count 1 2 161 175 18 Support Issue tracking Discussion forum Enterprise support Issue tracking Discussion forum Issue tracking Discussion forum Enterprise support Issue tracking Discussion forum Documentation \u2714 \u2714 \u2714 \u2714 Numbers specific for respective Github repository, as of 2021-11-30 \u21a9 \u21a9 \u21a9","title":"Evaluation Summary: OSS Characteristics"},{"location":"EvaluationSummary/PortabilityResults/","text":"Evaluation Summary: Portability The following table shows the results for the criteria defined in Criteria Catalog: Portability . Criterion Eventuate Tram Netflix Conductor Camunda MicroProfile LRA Containerization Docker Hub image Kubernetes examples Dockerfile & community Docker Hub image Docker Hub image Kubernetes examples Docker Hub image 1 Kubernetes examples 1 Cloud provider Camunda Cloud several guides 1 Depends on chosen MicroProfile runtime, here: OpenLiberty \u21a9 \u21a9 \u21a9","title":"Portability"},{"location":"EvaluationSummary/PortabilityResults/#evaluation-summary-portability","text":"The following table shows the results for the criteria defined in Criteria Catalog: Portability . Criterion Eventuate Tram Netflix Conductor Camunda MicroProfile LRA Containerization Docker Hub image Kubernetes examples Dockerfile & community Docker Hub image Docker Hub image Kubernetes examples Docker Hub image 1 Kubernetes examples 1 Cloud provider Camunda Cloud several guides 1 Depends on chosen MicroProfile runtime, here: OpenLiberty \u21a9 \u21a9 \u21a9","title":"Evaluation Summary: Portability"},{"location":"EvaluationSummary/SecurityResults/","text":"Evaluation Summary: Security The following table shows the results for the criteria defined in Criteria Catalog: Security . These aspects have not been implemented by the prototype application and are based on the respective technology documenentations. Criterion Eventuate Tram Netflix Conductor Camunda MicroProfile LRA Encrypted communication 1 \u2714 \u2714 \u2714 \u2714 Authentication support 1 \u2714 MicroProfile JWT 2 Authorization support 1 \u2714 MicroProfile JWT 2 Not implemented by the prototype \u21a9 \u21a9 \u21a9 https://download.eclipse.org/microprofile/microprofile-jwt-auth-1.2/microprofile-jwt-auth-spec-1.2.html , last accessed: 2021-07-11 \u21a9 \u21a9","title":"Security"},{"location":"EvaluationSummary/SecurityResults/#evaluation-summary-security","text":"The following table shows the results for the criteria defined in Criteria Catalog: Security . These aspects have not been implemented by the prototype application and are based on the respective technology documenentations. Criterion Eventuate Tram Netflix Conductor Camunda MicroProfile LRA Encrypted communication 1 \u2714 \u2714 \u2714 \u2714 Authentication support 1 \u2714 MicroProfile JWT 2 Authorization support 1 \u2714 MicroProfile JWT 2 Not implemented by the prototype \u21a9 \u21a9 \u21a9 https://download.eclipse.org/microprofile/microprofile-jwt-auth-1.2/microprofile-jwt-auth-spec-1.2.html , last accessed: 2021-07-11 \u21a9 \u21a9","title":"Evaluation Summary: Security"},{"location":"EvaluationSummary/TestabilityResults/","text":"Evaluation Summary: Testability The following table shows the results for the criteria defined in Criteria Catalog: Testability . The results regarding Saga integration tests have not been implemented by the prototype application and are based on the respective technology documenentations. Criterion Eventuate Tram Netflix Conductor Camunda MicroProfile LRA In-house test framework \u2714 \u2714 Unit test Saga definition \u2714 \u2714 successful Saga Unit test Saga participant \u2714 \u2714 \u2714 \u2714 Saga integration test 1 \u2714 \u2714 \u2714 \u2714 Not implemented by the prototype \u21a9","title":"Testability"},{"location":"EvaluationSummary/TestabilityResults/#evaluation-summary-testability","text":"The following table shows the results for the criteria defined in Criteria Catalog: Testability . The results regarding Saga integration tests have not been implemented by the prototype application and are based on the respective technology documenentations. Criterion Eventuate Tram Netflix Conductor Camunda MicroProfile LRA In-house test framework \u2714 \u2714 Unit test Saga definition \u2714 \u2714 successful Saga Unit test Saga participant \u2714 \u2714 \u2714 \u2714 Saga integration test 1 \u2714 \u2714 \u2714 \u2714 Not implemented by the prototype \u21a9","title":"Evaluation Summary: Testability"},{"location":"EventuateTram/EventuateTram_Expandability/","text":"Eventuate Tram Expandability Evaluation This project is part of the evaluation of a Saga pattern implementation using the Eventuate Tram and Eventuate Tram Sagas framework. The original Saga Pattern Realization with Eventuate Tram has been extended by a CustomerService in order to evaluate the expandability of an implementation using Eventuate Tram to realize the Saga pattern. The CustomerService has to authorize the customer before a hotel is being booked. Start the Application Run ./gradlew clean build Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html CustomerService http://localhost:8083/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available , use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" To simulate a Saga that fails because the customer validation failed , the customerId in the trip booking request has to be smaller than 1 , for example: { ... customerId: \"-1\" } Additionally, the Zipkin UI can be accessed to trace performed calls: http://localhost:9411/zipkin/ The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info CustomerService http://localhost:8083/api/customers/monitor/health http://localhost:8083/api/customers/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP). Stop the Application To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans Code Link EventuateTram_Implementations/EventuateTram_Expandability-Evaluation","title":"Expandability Evaluation"},{"location":"EventuateTram/EventuateTram_Expandability/#eventuate-tram-expandability-evaluation","text":"This project is part of the evaluation of a Saga pattern implementation using the Eventuate Tram and Eventuate Tram Sagas framework. The original Saga Pattern Realization with Eventuate Tram has been extended by a CustomerService in order to evaluate the expandability of an implementation using Eventuate Tram to realize the Saga pattern. The CustomerService has to authorize the customer before a hotel is being booked.","title":"Eventuate Tram Expandability Evaluation"},{"location":"EventuateTram/EventuateTram_Expandability/#start-the-application","text":"Run ./gradlew clean build Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html CustomerService http://localhost:8083/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available , use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" To simulate a Saga that fails because the customer validation failed , the customerId in the trip booking request has to be smaller than 1 , for example: { ... customerId: \"-1\" } Additionally, the Zipkin UI can be accessed to trace performed calls: http://localhost:9411/zipkin/ The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info CustomerService http://localhost:8083/api/customers/monitor/health http://localhost:8083/api/customers/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP).","title":"Start the Application"},{"location":"EventuateTram/EventuateTram_Expandability/#stop-the-application","text":"To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans","title":"Stop the Application"},{"location":"EventuateTram/EventuateTram_Expandability/#code-link","text":"EventuateTram_Implementations/EventuateTram_Expandability-Evaluation","title":"Code Link"},{"location":"EventuateTram/EventuateTram_FailurePerf/","text":"Eventuate Tram Failure Performance Evaluation This project is part of the evaluation of a Saga pattern implementation using the Eventuate Tram and Eventuate Tram Sagas framework. Additional sections to the original Saga Pattern Realization with Eventuate Tram have been included that simulate different failure scenarios given a particular input. Start the Application Run ./gradlew clean build Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html To simulate a Saga that fails because no hotel or no flight is available , use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" Additionally, the Zipkin UI can be accessed to trace performed calls: http://localhost:9411/zipkin/ The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP). Stop the Application To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans Provoke Failure Scenarios The respective String has to be used as destination country in the trip booking request to provoke a participant failure. An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Provoke orchestrator failure while starting trip booking\" , \"city\" : \"Bamberg\" }, \"travellerName\" : \"Orchestrator Start\" , \"boardType\" : \"All-inclusive\" , \"customerId\" : \"4\" } 1. Saga Participant Failure Provoke a failure of the FlightService participant before it started to execute a local transaction with the following string as destination country : \"Provoke participant failure before receiving task\" The HotelService terminates then the docker container of the FlightService while it is executing the bookHotel request. Afterwards, the FlightService has to be restarted manually to investigate what happens as soon as the service is running again. This can be done using one of the following commands: docker-compose start flightservice docker start flightservice_eventuateFailurePerf If the container name of the FlightService has been changed in the docker-compose.yml file, the container has to be started using this name. Provoke a termination failure of the FlightService participant while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke participant failure while executing\" The FlightService forces then its JVM to terminate itself, after booking a flight but before informing the orchestrator about it, in order to simulate a sudden failure of the system. Afterwards, the FlightService , again, has to be restarted using the same commands as above. Provoke an exception in the FlightService participant while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke exception while executing\" The FlightService throws then a RuntimeException while booking a flight to simulate unexpected behaviour of the system. Afterwards, the behaviour of the service can be observed. The easiest way is to have a look at the log of the FlightService during that time. This can be done using the following command: docker logs flightservice_eventuateFailurePerf --follow 2. Saga Orchestrator Failure The TravelService plays the orchestrator role in this example application. However, it also needs Eventuate's CDC service to publish messages to the participants and vice versa. Consequently, observing the system's behaviour during orchestrator failures involves failures of the TravelService as well as the CDC service . Provoke a failure of the CDC service while a trip booking is being started with the following string as destination country : \"Provoke orchestrator failure while starting trip booking\" The TravelService terminates then the docker container of the CDC Service while it is executing the bookTrip request but before starting the BookTripSaga . Afterwards, the CDC Service has to be restarted manually to investigate what happens as soon as the service is running again. This can be done using one of the following commands: docker-compose start cdcservice docker start cdcservice If the container name of the CDC service has been changed in the docker-compose.yml file, the container has to be started using this name. Provoke a failure of the CDC service while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke CDC failure while executing\" The FlightService terminates then the docker container of the CDC Service after booking a flight, but before informing the orchestrator about it. Afterwards, the CDC service , again, has to be restarted using the same commands as above. Provoke a failure of the orchestrator, which means the TravelService , while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke orchestrator failure while executing\" The FlightService terminates then the docker container of the TravelService after booking a flight, but before informing the orchestrator about it. Afterwards, the TravelService has to be restarted manually to investigate what happens as soon as the service is running again. This can be done using the same commands as before, but with travelservice as the service name, respectively travelservice_eventuateFailurePerf as the container name. 3. Breach of Saga Protocol A participant might send the same message twice to the orchestrator, or even send an old one. To handle such situations, EventuateTram offers a pluggable duplicate message detction mechanism 1 . For this the service's ApplicationContext has to define a DuplicateMessageDetector bean and the following dependency has to be added to the build.gradle file: compile \"io.eventuate.tram.core:eventuate-tram-spring-consumer-jdbc:$eventuateTramVersion\" Additionally, either auto\u2013configuration has to be enabled or @Import TramConsumerJdbcAutoConfiguration needs to be added. If this DuplicateMesageDetector is being used, managing transactions in the respective message handler classes needs to be deactivated, for exmaple remove using the @Transactional annotation. Code Link EventuateTram_Implementations/EventuateTram_FailurePerf-Evaluation https://eventuate.io/docs/manual/eventuate-tram/latest/getting-started-eventuate-tram.html#getting-started , last accessed 2022-02-15 \u21a9","title":"Fault Tolerance Evaluation"},{"location":"EventuateTram/EventuateTram_FailurePerf/#eventuate-tram-failure-performance-evaluation","text":"This project is part of the evaluation of a Saga pattern implementation using the Eventuate Tram and Eventuate Tram Sagas framework. Additional sections to the original Saga Pattern Realization with Eventuate Tram have been included that simulate different failure scenarios given a particular input.","title":"Eventuate Tram Failure Performance Evaluation"},{"location":"EventuateTram/EventuateTram_FailurePerf/#start-the-application","text":"Run ./gradlew clean build Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html To simulate a Saga that fails because no hotel or no flight is available , use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" Additionally, the Zipkin UI can be accessed to trace performed calls: http://localhost:9411/zipkin/ The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP).","title":"Start the Application"},{"location":"EventuateTram/EventuateTram_FailurePerf/#stop-the-application","text":"To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans","title":"Stop the Application"},{"location":"EventuateTram/EventuateTram_FailurePerf/#provoke-failure-scenarios","text":"The respective String has to be used as destination country in the trip booking request to provoke a participant failure. An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Provoke orchestrator failure while starting trip booking\" , \"city\" : \"Bamberg\" }, \"travellerName\" : \"Orchestrator Start\" , \"boardType\" : \"All-inclusive\" , \"customerId\" : \"4\" }","title":"Provoke Failure Scenarios"},{"location":"EventuateTram/EventuateTram_FailurePerf/#1-saga-participant-failure","text":"Provoke a failure of the FlightService participant before it started to execute a local transaction with the following string as destination country : \"Provoke participant failure before receiving task\" The HotelService terminates then the docker container of the FlightService while it is executing the bookHotel request. Afterwards, the FlightService has to be restarted manually to investigate what happens as soon as the service is running again. This can be done using one of the following commands: docker-compose start flightservice docker start flightservice_eventuateFailurePerf If the container name of the FlightService has been changed in the docker-compose.yml file, the container has to be started using this name. Provoke a termination failure of the FlightService participant while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke participant failure while executing\" The FlightService forces then its JVM to terminate itself, after booking a flight but before informing the orchestrator about it, in order to simulate a sudden failure of the system. Afterwards, the FlightService , again, has to be restarted using the same commands as above. Provoke an exception in the FlightService participant while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke exception while executing\" The FlightService throws then a RuntimeException while booking a flight to simulate unexpected behaviour of the system. Afterwards, the behaviour of the service can be observed. The easiest way is to have a look at the log of the FlightService during that time. This can be done using the following command: docker logs flightservice_eventuateFailurePerf --follow","title":"1. Saga Participant Failure"},{"location":"EventuateTram/EventuateTram_FailurePerf/#2-saga-orchestrator-failure","text":"The TravelService plays the orchestrator role in this example application. However, it also needs Eventuate's CDC service to publish messages to the participants and vice versa. Consequently, observing the system's behaviour during orchestrator failures involves failures of the TravelService as well as the CDC service . Provoke a failure of the CDC service while a trip booking is being started with the following string as destination country : \"Provoke orchestrator failure while starting trip booking\" The TravelService terminates then the docker container of the CDC Service while it is executing the bookTrip request but before starting the BookTripSaga . Afterwards, the CDC Service has to be restarted manually to investigate what happens as soon as the service is running again. This can be done using one of the following commands: docker-compose start cdcservice docker start cdcservice If the container name of the CDC service has been changed in the docker-compose.yml file, the container has to be started using this name. Provoke a failure of the CDC service while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke CDC failure while executing\" The FlightService terminates then the docker container of the CDC Service after booking a flight, but before informing the orchestrator about it. Afterwards, the CDC service , again, has to be restarted using the same commands as above. Provoke a failure of the orchestrator, which means the TravelService , while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke orchestrator failure while executing\" The FlightService terminates then the docker container of the TravelService after booking a flight, but before informing the orchestrator about it. Afterwards, the TravelService has to be restarted manually to investigate what happens as soon as the service is running again. This can be done using the same commands as before, but with travelservice as the service name, respectively travelservice_eventuateFailurePerf as the container name.","title":"2. Saga Orchestrator Failure"},{"location":"EventuateTram/EventuateTram_FailurePerf/#3-breach-of-saga-protocol","text":"A participant might send the same message twice to the orchestrator, or even send an old one. To handle such situations, EventuateTram offers a pluggable duplicate message detction mechanism 1 . For this the service's ApplicationContext has to define a DuplicateMessageDetector bean and the following dependency has to be added to the build.gradle file: compile \"io.eventuate.tram.core:eventuate-tram-spring-consumer-jdbc:$eventuateTramVersion\" Additionally, either auto\u2013configuration has to be enabled or @Import TramConsumerJdbcAutoConfiguration needs to be added. If this DuplicateMesageDetector is being used, managing transactions in the respective message handler classes needs to be deactivated, for exmaple remove using the @Transactional annotation.","title":"3. Breach of Saga Protocol"},{"location":"EventuateTram/EventuateTram_FailurePerf/#code-link","text":"EventuateTram_Implementations/EventuateTram_FailurePerf-Evaluation https://eventuate.io/docs/manual/eventuate-tram/latest/getting-started-eventuate-tram.html#getting-started , last accessed 2022-02-15 \u21a9","title":"Code Link"},{"location":"EventuateTram/EventuateTram_General/","text":"Saga Pattern Realization With Eventuate Tram This project includes an example implementation of the Saga pattern using the Eventuate Tram and Eventuate Tram Sagas framework. The example application represents a travel application that consists of three backend services: TravelService, HotelService and FlightService. For simplicity reasons, only the workflow for booking a trip has been implemented. Start the Application Run ./gradlew clean build Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP). Stop the Application To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans Monitor the Application MySQL Database The eventuate database, with its different tables, can be accessed with the following information, which is also included in the docker-compose.yaml file: Username: mysqluser | Password: mysqlpw Log Files Each service provides a log that contains some information about it. The logs can be accessed using the name of the relevant container. The different logs can be accessed using the following commands: Log of Command to execute TravelService docker logs travelservice_eventuate HotelService docker logs hotelservice_eventuate FlightService docker logs flightservice_eventuate By using the --follow supplement, it will be continued to stream the service's output to the console. The logging level can be changed in the respective application.properties file. Zipkin The services include the necessary gradle dependencies to enable distributed tracing with Zipkin when using the Eventuate Tram framework. The Zipkin UI can be accessed via http://localhost:9411/zipkin/ Metrics of the CDC Service Eventuate's CDC Service publishes some metrics like the number of processed messages. The metrics can be accessed via http://localhost:8099/actuator/prometheus Code Link EventuateTram_Implementations/EventuateTram","title":"Travel Application Realization"},{"location":"EventuateTram/EventuateTram_General/#saga-pattern-realization-with-eventuate-tram","text":"This project includes an example implementation of the Saga pattern using the Eventuate Tram and Eventuate Tram Sagas framework. The example application represents a travel application that consists of three backend services: TravelService, HotelService and FlightService. For simplicity reasons, only the workflow for booking a trip has been implemented.","title":"Saga Pattern Realization With Eventuate Tram"},{"location":"EventuateTram/EventuateTram_General/#start-the-application","text":"Run ./gradlew clean build Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP).","title":"Start the Application"},{"location":"EventuateTram/EventuateTram_General/#stop-the-application","text":"To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans","title":"Stop the Application"},{"location":"EventuateTram/EventuateTram_General/#monitor-the-application","text":"","title":"Monitor the Application"},{"location":"EventuateTram/EventuateTram_General/#mysql-database","text":"The eventuate database, with its different tables, can be accessed with the following information, which is also included in the docker-compose.yaml file: Username: mysqluser | Password: mysqlpw","title":"MySQL Database"},{"location":"EventuateTram/EventuateTram_General/#log-files","text":"Each service provides a log that contains some information about it. The logs can be accessed using the name of the relevant container. The different logs can be accessed using the following commands: Log of Command to execute TravelService docker logs travelservice_eventuate HotelService docker logs hotelservice_eventuate FlightService docker logs flightservice_eventuate By using the --follow supplement, it will be continued to stream the service's output to the console. The logging level can be changed in the respective application.properties file.","title":"Log Files"},{"location":"EventuateTram/EventuateTram_General/#zipkin","text":"The services include the necessary gradle dependencies to enable distributed tracing with Zipkin when using the Eventuate Tram framework. The Zipkin UI can be accessed via http://localhost:9411/zipkin/","title":"Zipkin"},{"location":"EventuateTram/EventuateTram_General/#metrics-of-the-cdc-service","text":"Eventuate's CDC Service publishes some metrics like the number of processed messages. The metrics can be accessed via http://localhost:8099/actuator/prometheus","title":"Metrics of the CDC Service"},{"location":"EventuateTram/EventuateTram_General/#code-link","text":"EventuateTram_Implementations/EventuateTram","title":"Code Link"},{"location":"EventuateTram/EventuateTram_Testability/","text":"Eventuate Tram Testability Evaluation This project is part of the evaluation of a Saga pattern implementation using the Eventuate Tram and Eventuate Tram Sagas framework. The original Saga Pattern Realization with Eventuate Tram has been extended by automated tests that relate to the BookTripSaga. Start the Application Run ./gradlew clean build Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP). Stop the Application To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans Testability The TravelService as well as the HotelService have a testing directory that includes several tests concerning Saga-related code. 1. Unit Test Saga Definition Unit tests regarding the Saga orchestrator and the Saga definition can be found within the TravelService . Since Eventuate Tram provides a testing framework specifically designed for testing Sagas, it is used here. 2. Unit Test Saga Participant Examples for unit testing the Saga participant can be found within the HotelService . Again, Eventuate Tram's testing framework is used to realize the participant related unit tests. Code Link EventuateTram_Implementations/EventuateTram_Testability-Evaluation","title":"Testability Evaluation"},{"location":"EventuateTram/EventuateTram_Testability/#eventuate-tram-testability-evaluation","text":"This project is part of the evaluation of a Saga pattern implementation using the Eventuate Tram and Eventuate Tram Sagas framework. The original Saga Pattern Realization with Eventuate Tram has been extended by automated tests that relate to the BookTripSaga.","title":"Eventuate Tram Testability Evaluation"},{"location":"EventuateTram/EventuateTram_Testability/#start-the-application","text":"Run ./gradlew clean build Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP).","title":"Start the Application"},{"location":"EventuateTram/EventuateTram_Testability/#stop-the-application","text":"To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans","title":"Stop the Application"},{"location":"EventuateTram/EventuateTram_Testability/#testability","text":"The TravelService as well as the HotelService have a testing directory that includes several tests concerning Saga-related code.","title":"Testability"},{"location":"EventuateTram/EventuateTram_Testability/#1-unit-test-saga-definition","text":"Unit tests regarding the Saga orchestrator and the Saga definition can be found within the TravelService . Since Eventuate Tram provides a testing framework specifically designed for testing Sagas, it is used here.","title":"1. Unit Test Saga Definition"},{"location":"EventuateTram/EventuateTram_Testability/#2-unit-test-saga-participant","text":"Examples for unit testing the Saga participant can be found within the HotelService . Again, Eventuate Tram's testing framework is used to realize the participant related unit tests.","title":"2. Unit Test Saga Participant"},{"location":"EventuateTram/EventuateTram_Testability/#code-link","text":"EventuateTram_Implementations/EventuateTram_Testability-Evaluation","title":"Code Link"},{"location":"MicroProfile/MicroProfile_Expandability/","text":"MicroProfile LRA Expandability Evaluation This project is part of the evaluation of a Saga pattern implementation using MicroProfile LRA . The original Saga Pattern Realization with MicroProfile LRA has been extended by a CustomerService in order to evaluate the expandability of an implementation using Eventuate Tram to realize the Saga pattern. The CustomerService has to authorize the customer before a hotel is being booked. Start the Application Run ./gradlew clean build Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/openapi/ui/ LRA Coordinator (included in TravelService) HotelService http://localhost:8081/openapi/ui/ FlightService http://localhost:8082/openapi/ui/ CustomerService http://localhost:8083/openapi/ui/ An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available , use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" To simulate a Saga that fails because the customer validation failed , the customerId in the trip booking request has to be smaller than 1 , for example: { ... customerId: \"-1\" } The services also provide a general health endpoint that shows information about the system whether it is up and running. These endpoints can be accessed via: Service URL to health endpoint TravelService http://localhost:8090/health HotelService http://localhost:8081/health FlightService http://localhost:8082/health CustomerService http://localhost:8083/health If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP). Stop the Application To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans Code Link MicroProfile_Implementations/MicroProfile_Expandability-Evaluation","title":"Expandability Evaluation"},{"location":"MicroProfile/MicroProfile_Expandability/#microprofile-lra-expandability-evaluation","text":"This project is part of the evaluation of a Saga pattern implementation using MicroProfile LRA . The original Saga Pattern Realization with MicroProfile LRA has been extended by a CustomerService in order to evaluate the expandability of an implementation using Eventuate Tram to realize the Saga pattern. The CustomerService has to authorize the customer before a hotel is being booked.","title":"MicroProfile LRA Expandability Evaluation"},{"location":"MicroProfile/MicroProfile_Expandability/#start-the-application","text":"Run ./gradlew clean build Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/openapi/ui/ LRA Coordinator (included in TravelService) HotelService http://localhost:8081/openapi/ui/ FlightService http://localhost:8082/openapi/ui/ CustomerService http://localhost:8083/openapi/ui/ An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available , use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" To simulate a Saga that fails because the customer validation failed , the customerId in the trip booking request has to be smaller than 1 , for example: { ... customerId: \"-1\" } The services also provide a general health endpoint that shows information about the system whether it is up and running. These endpoints can be accessed via: Service URL to health endpoint TravelService http://localhost:8090/health HotelService http://localhost:8081/health FlightService http://localhost:8082/health CustomerService http://localhost:8083/health If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP).","title":"Start the Application"},{"location":"MicroProfile/MicroProfile_Expandability/#stop-the-application","text":"To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans","title":"Stop the Application"},{"location":"MicroProfile/MicroProfile_Expandability/#code-link","text":"MicroProfile_Implementations/MicroProfile_Expandability-Evaluation","title":"Code Link"},{"location":"MicroProfile/MicroProfile_FailurePerf/","text":"MicroProfile LRA Failure Performance Evaluation This project is part of the evaluation of a Saga pattern implementation using MicroProfile LRA . Additional sections to the original Saga Pattern Realization with MicroProfile LRA have been included that simulate different failure scenarios given a particular input. Start the Application Run ./gradlew clean build Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/openapi/ui/ LRA Coordinator (included in TravelService) HotelService http://localhost:8081/openapi/ui/ FlightService http://localhost:8082/openapi/ui/ To simulate a Saga that fails because no hotel or no flight is available , use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" The services also provide a general health endpoint that shows information about the system whether it is up and running. These endpoints can be accessed via: Service URL to health endpoint TravelService http://localhost:8090/health HotelService http://localhost:8081/health FlightService http://localhost:8082/health If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP). Stop the Application To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans Provoke Failure Scenarios The respective String has to be used as destination country in the trip booking request to provoke a participant failure. An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Provoke orchestrator failure while starting trip booking\" , \"city\" : \"Bamberg\" }, \"travellerName\" : \"Orchestrator Start\" , \"boardType\" : \"All-inclusive\" , \"customerId\" : \"4\" } 1. Saga Participant Failure Provoke a failure of the FlightService participant before it started to execute a local transaction with the following string as destination country : \"Provoke participant failure before receiving task\" The HotelService terminates then the docker container of the FlightService while it is executing the bookHotel request. Afterwards, the FlightService has to be restarted manually to investigate what happens as soon as the service is running again. This can be done using one of the following commands: docker-compose start flightservice docker start flightservice_conductorFailurePerf If the container name of the FlightService has been changed in the docker-compose.yml file, the container has to be started using this name with the docker start command. The same applies for the docker-compose start command if the service name of the FlightService has been changed in the docker-compose.yml file. Provoke a termination failure of the FlightService participant while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke participant failure while executing\" The FlightService forces then its JVM to terminate itself, after booking a flight but before informing the orchestrator about it, in order to simulate a sudden failure of the system. Afterwards, the FlightService , again, has to be restarted using the same commands as above. Provoke an exception in the FlightService participant while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke exception while executing\" The FlightService throws then a RuntimeException while booking a flight to simulate unexpected behaviour of the system. Afterwards, the behaviour of the service can be observed. The easiest way is to have a look at the log of the FlightService during that time. This can be done using the following command: shell docker logs flightservice_conductorFailurePerf --follow 2. Saga Orchestrator Failure The LRA Coordinator within the TravelService , as well as the TravelService itself are the orchestrator in this example application. Consequently, observing the system's behaviour during orchestrator failures involves failures of this service. Provoke a failure of the TravelService while a trip booking is being started is not considered, since the TravelService is needed in order to make booking requests. Provoke a failure of the TravelService while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke orchestrator failure while executing\" The FlightService terminates then the docker container of the TravelService after booking a flight, but before informing the orchestrator about it. Afterwards, the TravelService has to be restarted manually to investigate what happens as soon as the service is running again. This can be done using one of the following commands: docker-compose start conductor-server-ui docker start conductor-server-ui If the container name of the TravelService has been changed in the docker-compose.yml file, the container has to be started using this name. 3. Breach of Saga Protocol A participant might send the same message twice to the orchestrator, or even send an old one. Therefore, the scenario of sending an old message to the orchestrator has been added to the implementation in order to evaluate how an implementation using MicroProfile LRA handles this situation. Provoke the HotelService to send an old message to the LRACoordinator with the following string as destination country : \"Provoke sending old message to orchestrator\" When the complete endpoint of the HotelService is invoked by the LRACoordinator , the HotelService creates then a new thread that waits for five minutes before it sends the same answer as before to the LRACoordinator again. To achieve this, the HotelService sends the old message, in this case the lraId , to the provided endpoint /{lraID}/close . The service's logs document when it sends the old message. Code Link MicroProfile_Implementations/MicroProfile_FailurePerf-Evaluation","title":"Fault Tolerance Evaluation"},{"location":"MicroProfile/MicroProfile_FailurePerf/#microprofile-lra-failure-performance-evaluation","text":"This project is part of the evaluation of a Saga pattern implementation using MicroProfile LRA . Additional sections to the original Saga Pattern Realization with MicroProfile LRA have been included that simulate different failure scenarios given a particular input.","title":"MicroProfile LRA Failure Performance Evaluation"},{"location":"MicroProfile/MicroProfile_FailurePerf/#start-the-application","text":"Run ./gradlew clean build Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/openapi/ui/ LRA Coordinator (included in TravelService) HotelService http://localhost:8081/openapi/ui/ FlightService http://localhost:8082/openapi/ui/ To simulate a Saga that fails because no hotel or no flight is available , use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" The services also provide a general health endpoint that shows information about the system whether it is up and running. These endpoints can be accessed via: Service URL to health endpoint TravelService http://localhost:8090/health HotelService http://localhost:8081/health FlightService http://localhost:8082/health If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP).","title":"Start the Application"},{"location":"MicroProfile/MicroProfile_FailurePerf/#stop-the-application","text":"To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans","title":"Stop the Application"},{"location":"MicroProfile/MicroProfile_FailurePerf/#provoke-failure-scenarios","text":"The respective String has to be used as destination country in the trip booking request to provoke a participant failure. An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Provoke orchestrator failure while starting trip booking\" , \"city\" : \"Bamberg\" }, \"travellerName\" : \"Orchestrator Start\" , \"boardType\" : \"All-inclusive\" , \"customerId\" : \"4\" }","title":"Provoke Failure Scenarios"},{"location":"MicroProfile/MicroProfile_FailurePerf/#1-saga-participant-failure","text":"Provoke a failure of the FlightService participant before it started to execute a local transaction with the following string as destination country : \"Provoke participant failure before receiving task\" The HotelService terminates then the docker container of the FlightService while it is executing the bookHotel request. Afterwards, the FlightService has to be restarted manually to investigate what happens as soon as the service is running again. This can be done using one of the following commands: docker-compose start flightservice docker start flightservice_conductorFailurePerf If the container name of the FlightService has been changed in the docker-compose.yml file, the container has to be started using this name with the docker start command. The same applies for the docker-compose start command if the service name of the FlightService has been changed in the docker-compose.yml file. Provoke a termination failure of the FlightService participant while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke participant failure while executing\" The FlightService forces then its JVM to terminate itself, after booking a flight but before informing the orchestrator about it, in order to simulate a sudden failure of the system. Afterwards, the FlightService , again, has to be restarted using the same commands as above. Provoke an exception in the FlightService participant while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke exception while executing\" The FlightService throws then a RuntimeException while booking a flight to simulate unexpected behaviour of the system. Afterwards, the behaviour of the service can be observed. The easiest way is to have a look at the log of the FlightService during that time. This can be done using the following command: shell docker logs flightservice_conductorFailurePerf --follow","title":"1. Saga Participant Failure"},{"location":"MicroProfile/MicroProfile_FailurePerf/#2-saga-orchestrator-failure","text":"The LRA Coordinator within the TravelService , as well as the TravelService itself are the orchestrator in this example application. Consequently, observing the system's behaviour during orchestrator failures involves failures of this service. Provoke a failure of the TravelService while a trip booking is being started is not considered, since the TravelService is needed in order to make booking requests. Provoke a failure of the TravelService while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke orchestrator failure while executing\" The FlightService terminates then the docker container of the TravelService after booking a flight, but before informing the orchestrator about it. Afterwards, the TravelService has to be restarted manually to investigate what happens as soon as the service is running again. This can be done using one of the following commands: docker-compose start conductor-server-ui docker start conductor-server-ui If the container name of the TravelService has been changed in the docker-compose.yml file, the container has to be started using this name.","title":"2. Saga Orchestrator Failure"},{"location":"MicroProfile/MicroProfile_FailurePerf/#3-breach-of-saga-protocol","text":"A participant might send the same message twice to the orchestrator, or even send an old one. Therefore, the scenario of sending an old message to the orchestrator has been added to the implementation in order to evaluate how an implementation using MicroProfile LRA handles this situation. Provoke the HotelService to send an old message to the LRACoordinator with the following string as destination country : \"Provoke sending old message to orchestrator\" When the complete endpoint of the HotelService is invoked by the LRACoordinator , the HotelService creates then a new thread that waits for five minutes before it sends the same answer as before to the LRACoordinator again. To achieve this, the HotelService sends the old message, in this case the lraId , to the provided endpoint /{lraID}/close . The service's logs document when it sends the old message.","title":"3. Breach of Saga Protocol"},{"location":"MicroProfile/MicroProfile_FailurePerf/#code-link","text":"MicroProfile_Implementations/MicroProfile_FailurePerf-Evaluation","title":"Code Link"},{"location":"MicroProfile/MicroProfile_General/","text":"Saga Pattern Realization With MicroProfile LRA This project includes an example implementation of the Saga pattern using MicroProfile LRA . The example application represents a travel application that consists of three backend services: TravelService, HotelService and FlightService. For simplicity reasons, only the workflow for booking a trip has been implemented. Start the Application Run ./gradlew clean build Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/openapi/ui/ LRA Coordinator (included in TravelService) HotelService http://localhost:8081/openapi/ui/ FlightService http://localhost:8082/openapi/ui/ An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" The services also provide a general health endpoint that shows information about the system whether it is up and running. These endpoints can be accessed via: Service URL to health endpoint TravelService http://localhost:8090/health HotelService http://localhost:8081/health FlightService http://localhost:8082/health If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP). Stop the Application To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans General Saga Characteristics External Compensation Trigger In order to start the compensation of a currently running Saga externally, the LRA coordinator offers an endpoint to trigger the compensation of a specific LRA. To achieve that, an empty PUT request has to be sent to the LRA coordinator at: http://localhost:8090/lrac/lra-coordinator/{lraId}/cancel The TravelApplication.json insomnia file also includes this request within the ExternalCompensationTrigger directory. Monitor the Application Log Files Each service provides a log that contains some information about it. The logs can be accessed using the name of the relevant container. The different logs can be accessed using the following commands: Log of Command to execute TravelService docker logs travelservice_microProfile HotelService docker logs hotelservice_microProfile FlightService docker logs flightservice_microProfile By using the --follow supplement, it will be continued to stream the service's output to the console. The logging level can be changed in the respective application.properties file. Tracing The services include the necessary gradle dependencies as well as the feature within the server.xml to enable distributed tracing with Zipkin or with Jaeger . If tracing with Jaeger is enabled, Zipkin will not work. Information on how to activate/deactivate the respective tracing technology is described in the following two subsections. The default is that Zipkin is activated and Jaeger deactivated. Here, the main difference between Zipkin and Jaeger is that only Zipkin also shows the traces for requests to the LRA Coordinator. a) Zipkin The Zipkin UI can be accessed via http://localhost:9411/zipkin/ The following shortly describes how to activate and deactivate tracing with Zipkin: Activate Zipkin [default] : Go to the respective server.xml and uncomment the following line within the featureManager section <feature> usr:opentracingZipkin-0.33 </feature> The following line must also be uncommented within the server.xml : <opentracingZipkin host= \"${zipkin.host}\" port= \"9411\" /> Additionally, the following line should be active within the respective build.gradle : compile \"WASdev:sample.opentracing.zipkintracer:2.0.1@zip\" Additionally, make sure that the Zipkin service is active within the docker-compose.yml and that the following environment variable is set for each microservice: ZIPKIN_URI : zipkin Deactivate Zipkin : Go to the respective server.xml and comment the following line out within the featureManager section <feature> usr:opentracingZipkin-0.33 </feature> Additionally, the following line must also be commented out within the server.xml : <opentracingZipkin host= \"${zipkin.host}\" port= \"9411\" /> b) Jaeger The Jaeger UI can be accessed via http://localhost:16686/ The following shortly describes how to activate and deactivate tracing with Jaeger: Activate Jaeger : Go to the respective build.gradle files and activate within the dependencies section the following line: compile \"io.jaegertracing:jaeger-client:1.6.0\" Additionally, make sure that the Jaeger service is active within the docker-compose.yml and that the following four environment variables are set and active for each microservice: JAEGER_AGENT_HOST : jaeger JAEGER_AGENT_PORT : 6831 JAEGER_SAMPLER_TYPE : const JAEGER_SAMPLER_PARAM : 1 Deactivate Jaeger [default] : Go to the respective build.gradle files and comment out, within the dependencies section, the following line: compile \"io.jaegertracing:jaeger-client:1.6.0\" Metrics The individual microservices are publishing some metrics like the number of executed requests to a specific endpoint. Additionally, the LRA Coordinator publishes some metrics like the maximum duration time of closing an LRA. These metrics are also published by the TravelService since the TravelService includes the coordinator. Service URL to Swagger UI TravelService http://localhost:8090/metrics/ LRA Coordinator (included in TravelService) HotelService http://localhost:8081/metrics/ FlightService http://localhost:8082/metrics/ Code Link MicroProfile_Implementations/MicroProfile","title":"Travel Application Realization"},{"location":"MicroProfile/MicroProfile_General/#saga-pattern-realization-with-microprofile-lra","text":"This project includes an example implementation of the Saga pattern using MicroProfile LRA . The example application represents a travel application that consists of three backend services: TravelService, HotelService and FlightService. For simplicity reasons, only the workflow for booking a trip has been implemented.","title":"Saga Pattern Realization With MicroProfile LRA"},{"location":"MicroProfile/MicroProfile_General/#start-the-application","text":"Run ./gradlew clean build Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/openapi/ui/ LRA Coordinator (included in TravelService) HotelService http://localhost:8081/openapi/ui/ FlightService http://localhost:8082/openapi/ui/ An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" The services also provide a general health endpoint that shows information about the system whether it is up and running. These endpoints can be accessed via: Service URL to health endpoint TravelService http://localhost:8090/health HotelService http://localhost:8081/health FlightService http://localhost:8082/health If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP).","title":"Start the Application"},{"location":"MicroProfile/MicroProfile_General/#stop-the-application","text":"To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans","title":"Stop the Application"},{"location":"MicroProfile/MicroProfile_General/#general-saga-characteristics","text":"","title":"General Saga Characteristics"},{"location":"MicroProfile/MicroProfile_General/#external-compensation-trigger","text":"In order to start the compensation of a currently running Saga externally, the LRA coordinator offers an endpoint to trigger the compensation of a specific LRA. To achieve that, an empty PUT request has to be sent to the LRA coordinator at: http://localhost:8090/lrac/lra-coordinator/{lraId}/cancel The TravelApplication.json insomnia file also includes this request within the ExternalCompensationTrigger directory.","title":"External Compensation Trigger"},{"location":"MicroProfile/MicroProfile_General/#monitor-the-application","text":"","title":"Monitor the Application"},{"location":"MicroProfile/MicroProfile_General/#log-files","text":"Each service provides a log that contains some information about it. The logs can be accessed using the name of the relevant container. The different logs can be accessed using the following commands: Log of Command to execute TravelService docker logs travelservice_microProfile HotelService docker logs hotelservice_microProfile FlightService docker logs flightservice_microProfile By using the --follow supplement, it will be continued to stream the service's output to the console. The logging level can be changed in the respective application.properties file.","title":"Log Files"},{"location":"MicroProfile/MicroProfile_General/#tracing","text":"The services include the necessary gradle dependencies as well as the feature within the server.xml to enable distributed tracing with Zipkin or with Jaeger . If tracing with Jaeger is enabled, Zipkin will not work. Information on how to activate/deactivate the respective tracing technology is described in the following two subsections. The default is that Zipkin is activated and Jaeger deactivated. Here, the main difference between Zipkin and Jaeger is that only Zipkin also shows the traces for requests to the LRA Coordinator.","title":"Tracing"},{"location":"MicroProfile/MicroProfile_General/#a-zipkin","text":"The Zipkin UI can be accessed via http://localhost:9411/zipkin/ The following shortly describes how to activate and deactivate tracing with Zipkin: Activate Zipkin [default] : Go to the respective server.xml and uncomment the following line within the featureManager section <feature> usr:opentracingZipkin-0.33 </feature> The following line must also be uncommented within the server.xml : <opentracingZipkin host= \"${zipkin.host}\" port= \"9411\" /> Additionally, the following line should be active within the respective build.gradle : compile \"WASdev:sample.opentracing.zipkintracer:2.0.1@zip\" Additionally, make sure that the Zipkin service is active within the docker-compose.yml and that the following environment variable is set for each microservice: ZIPKIN_URI : zipkin Deactivate Zipkin : Go to the respective server.xml and comment the following line out within the featureManager section <feature> usr:opentracingZipkin-0.33 </feature> Additionally, the following line must also be commented out within the server.xml : <opentracingZipkin host= \"${zipkin.host}\" port= \"9411\" />","title":"a) Zipkin"},{"location":"MicroProfile/MicroProfile_General/#b-jaeger","text":"The Jaeger UI can be accessed via http://localhost:16686/ The following shortly describes how to activate and deactivate tracing with Jaeger: Activate Jaeger : Go to the respective build.gradle files and activate within the dependencies section the following line: compile \"io.jaegertracing:jaeger-client:1.6.0\" Additionally, make sure that the Jaeger service is active within the docker-compose.yml and that the following four environment variables are set and active for each microservice: JAEGER_AGENT_HOST : jaeger JAEGER_AGENT_PORT : 6831 JAEGER_SAMPLER_TYPE : const JAEGER_SAMPLER_PARAM : 1 Deactivate Jaeger [default] : Go to the respective build.gradle files and comment out, within the dependencies section, the following line: compile \"io.jaegertracing:jaeger-client:1.6.0\"","title":"b) Jaeger"},{"location":"MicroProfile/MicroProfile_General/#metrics","text":"The individual microservices are publishing some metrics like the number of executed requests to a specific endpoint. Additionally, the LRA Coordinator publishes some metrics like the maximum duration time of closing an LRA. These metrics are also published by the TravelService since the TravelService includes the coordinator. Service URL to Swagger UI TravelService http://localhost:8090/metrics/ LRA Coordinator (included in TravelService) HotelService http://localhost:8081/metrics/ FlightService http://localhost:8082/metrics/","title":"Metrics"},{"location":"MicroProfile/MicroProfile_General/#code-link","text":"MicroProfile_Implementations/MicroProfile","title":"Code Link"},{"location":"MicroProfile/MicroProfile_ParallelExec/","text":"MicroProfile LRA Parallel Execution Evaluation This project includes an example implementation of the Saga pattern using MicroProfile LRA . The difference to the original Saga Pattern Realization with MicroProfile LRA is the parallel execution of specific tasks instead of a sequential one. Start the Application Run ./gradlew clean build Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/openapi/ui/ LRA Coordinator (included in TravelService) HotelService http://localhost:8081/openapi/ui/ FlightService http://localhost:8082/openapi/ui/ An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" The services also provide a general health endpoint that shows information about the system whether it is up and running. These endpoints can be accessed via: Service URL to health endpoint TravelService http://localhost:8090/health HotelService http://localhost:8081/health FlightService http://localhost:8082/health If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine ( use docker-machine ip default to get this default IP). Stop the Application To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans Parallel Execution of Tasks The bookHotel and the bookFlight requests, as well as the confirmHotel and the confirmTrip requests, are now executed in parallel by asynchronously invoking the endpoints. However, the confirmTrip request is responsible for ending the LRA. Therefore, it can only be executed in parallel with requests that will always succeed. Additionally, the LRA Coordinator invokes the compensations, so this execution cannot be influenced. Code Link MicroProfile_Implementations/MicroProfile_ParallelExec-Evaluation","title":"Parallel Execution Evaluation"},{"location":"MicroProfile/MicroProfile_ParallelExec/#microprofile-lra-parallel-execution-evaluation","text":"This project includes an example implementation of the Saga pattern using MicroProfile LRA . The difference to the original Saga Pattern Realization with MicroProfile LRA is the parallel execution of specific tasks instead of a sequential one.","title":"MicroProfile LRA Parallel Execution Evaluation"},{"location":"MicroProfile/MicroProfile_ParallelExec/#start-the-application","text":"Run ./gradlew clean build Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/openapi/ui/ LRA Coordinator (included in TravelService) HotelService http://localhost:8081/openapi/ui/ FlightService http://localhost:8082/openapi/ui/ An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" The services also provide a general health endpoint that shows information about the system whether it is up and running. These endpoints can be accessed via: Service URL to health endpoint TravelService http://localhost:8090/health HotelService http://localhost:8081/health FlightService http://localhost:8082/health If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine ( use docker-machine ip default to get this default IP).","title":"Start the Application"},{"location":"MicroProfile/MicroProfile_ParallelExec/#stop-the-application","text":"To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans","title":"Stop the Application"},{"location":"MicroProfile/MicroProfile_ParallelExec/#parallel-execution-of-tasks","text":"The bookHotel and the bookFlight requests, as well as the confirmHotel and the confirmTrip requests, are now executed in parallel by asynchronously invoking the endpoints. However, the confirmTrip request is responsible for ending the LRA. Therefore, it can only be executed in parallel with requests that will always succeed. Additionally, the LRA Coordinator invokes the compensations, so this execution cannot be influenced.","title":"Parallel Execution of Tasks"},{"location":"MicroProfile/MicroProfile_ParallelExec/#code-link","text":"MicroProfile_Implementations/MicroProfile_ParallelExec-Evaluation","title":"Code Link"},{"location":"MicroProfile/MicroProfile_Testability/","text":"MicroProfile LRA Testability Evaluation This project is part of the evaluation of a Saga pattern implementation using MicroProfile LRA . The original Saga Pattern Realization with MicroProfile LRA has been extended by automated tests that relate to the BookTripSaga. Start the Application Run ./gradlew clean build -x test Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/openapi/ui/ LRA Coordinator (included in TravelService) HotelService http://localhost:8081/openapi/ui/ FlightService http://localhost:8082/openapi/ui/ An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" The services also provide a general health endpoint that shows information about the system whether it is up and running. These endpoints can be accessed via: Service URL to health endpoint TravelService http://localhost:8090/health HotelService http://localhost:8081/health FlightService http://localhost:8082/health If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP). Stop the Application To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans Testability The TravelService as well as the HotelService have a testing directory that includes several tests concerning Saga\u2013related code. 1. Unit Test Saga Definition Unit tests regarding the Saga orchestrator and the Saga definition can be found within the TravelService . However, Camunda does not provide a testing framework and it is only possible to test the Saga definition for a successful Saga execution due to the annotation\u2013based compensation mechanism. The tests are realized using JUnit and Mockito . 2. Unit Test Saga Participant Examples for unit testing the Saga participant can be found within the HotelService . Again, unit tests for a Saga participant are realized using JUnit and Mockito . Code Link MicroProfile_Implementations/MicroProfile_Testability-Evaluation","title":"Testability Evaluation"},{"location":"MicroProfile/MicroProfile_Testability/#microprofile-lra-testability-evaluation","text":"This project is part of the evaluation of a Saga pattern implementation using MicroProfile LRA . The original Saga Pattern Realization with MicroProfile LRA has been extended by automated tests that relate to the BookTripSaga.","title":"MicroProfile LRA Testability Evaluation"},{"location":"MicroProfile/MicroProfile_Testability/#start-the-application","text":"Run ./gradlew clean build -x test Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/openapi/ui/ LRA Coordinator (included in TravelService) HotelService http://localhost:8081/openapi/ui/ FlightService http://localhost:8082/openapi/ui/ An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" The services also provide a general health endpoint that shows information about the system whether it is up and running. These endpoints can be accessed via: Service URL to health endpoint TravelService http://localhost:8090/health HotelService http://localhost:8081/health FlightService http://localhost:8082/health If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP).","title":"Start the Application"},{"location":"MicroProfile/MicroProfile_Testability/#stop-the-application","text":"To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans","title":"Stop the Application"},{"location":"MicroProfile/MicroProfile_Testability/#testability","text":"The TravelService as well as the HotelService have a testing directory that includes several tests concerning Saga\u2013related code.","title":"Testability"},{"location":"MicroProfile/MicroProfile_Testability/#1-unit-test-saga-definition","text":"Unit tests regarding the Saga orchestrator and the Saga definition can be found within the TravelService . However, Camunda does not provide a testing framework and it is only possible to test the Saga definition for a successful Saga execution due to the annotation\u2013based compensation mechanism. The tests are realized using JUnit and Mockito .","title":"1. Unit Test Saga Definition"},{"location":"MicroProfile/MicroProfile_Testability/#2-unit-test-saga-participant","text":"Examples for unit testing the Saga participant can be found within the HotelService . Again, unit tests for a Saga participant are realized using JUnit and Mockito .","title":"2. Unit Test Saga Participant"},{"location":"MicroProfile/MicroProfile_Testability/#code-link","text":"MicroProfile_Implementations/MicroProfile_Testability-Evaluation","title":"Code Link"},{"location":"NetflixConductor/NetflixConductor_Expandability/","text":"Netflix Conductor Expandability Evaluation This project is part of the evaluation of a Saga pattern implementation using Netflix Conductor . The original Saga Pattern Realization With Netflix Conductor has been extended by a CustomerService in order to evaluate the expandability of an implementation using Netflix Conductor to realize the Saga pattern. The CustomerService has to authorize the customer before a hotel is being booked. Start the Application Run ./gradlew clean build Execute docker-compose up --no-start Execute docker-compose start elasticsearch Execute docker-compose start dynomite Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html CustomerService http://localhost:8083/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available , use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" To simulate a Saga that fails because the customer validation failed , the customerId in the trip booking request has to be smaller than 1 , for example: { ... customerId: \"-1\" } Additionally, the Conductor UI can be accessed via http://localhost:5000/ and the Swagger UI of the Conductor server via http://localhost:8080/ . The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info CustomerService http://localhost:8083/api/customers/monitor/health http://localhost:8083/api/customers/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP). Stop the Application To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans Code Link NetflixConductor_Implementations/NetflixConductor_Expandability-Evaluation","title":"Expandability Evaluation"},{"location":"NetflixConductor/NetflixConductor_Expandability/#netflix-conductor-expandability-evaluation","text":"This project is part of the evaluation of a Saga pattern implementation using Netflix Conductor . The original Saga Pattern Realization With Netflix Conductor has been extended by a CustomerService in order to evaluate the expandability of an implementation using Netflix Conductor to realize the Saga pattern. The CustomerService has to authorize the customer before a hotel is being booked.","title":"Netflix Conductor Expandability Evaluation"},{"location":"NetflixConductor/NetflixConductor_Expandability/#start-the-application","text":"Run ./gradlew clean build Execute docker-compose up --no-start Execute docker-compose start elasticsearch Execute docker-compose start dynomite Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html CustomerService http://localhost:8083/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available , use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" To simulate a Saga that fails because the customer validation failed , the customerId in the trip booking request has to be smaller than 1 , for example: { ... customerId: \"-1\" } Additionally, the Conductor UI can be accessed via http://localhost:5000/ and the Swagger UI of the Conductor server via http://localhost:8080/ . The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info CustomerService http://localhost:8083/api/customers/monitor/health http://localhost:8083/api/customers/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP).","title":"Start the Application"},{"location":"NetflixConductor/NetflixConductor_Expandability/#stop-the-application","text":"To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans","title":"Stop the Application"},{"location":"NetflixConductor/NetflixConductor_Expandability/#code-link","text":"NetflixConductor_Implementations/NetflixConductor_Expandability-Evaluation","title":"Code Link"},{"location":"NetflixConductor/NetflixConductor_FailurePerf/","text":"Netflix Conductor Failure Performance Evaluation This project is part of the evaluation of a Saga pattern implementation using Netflix Conductor . Additional sections to the original Saga Pattern Realization With Netflix Conductor have been included that simulate different failure scenarios given a particular input. Start the Application Run ./gradlew clean build Execute docker-compose up --no-start Execute docker-compose start elasticsearch Execute docker-compose start dynomite Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html To simulate a Saga that fails because no hotel or no flight is available , use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" Additionally, the Conductor UI can be accessed via http://localhost:5000/ and the Swagger UI of the Conductor server via http://localhost:8080/ . The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP). Stop the Application To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans Provoke Failure Scenarios The respective String has to be used as destination country in the trip booking request to provoke a participant failure. An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Provoke orchestrator failure while starting trip booking\" , \"city\" : \"Bamberg\" }, \"travellerName\" : \"Orchestrator Start\" , \"boardType\" : \"All-inclusive\" , \"customerId\" : \"4\" } 1. Saga Participant Failure Provoke a failure of the FlightService participant before it started to execute a local transaction with the following string as destination country : \"Provoke participant failure before receiving task\" The HotelService terminates then the docker container of the FlightService while it is executing the bookHotel request. Afterwards, the FlightService has to be restarted manually to investigate what happens as soon as the service is running again. This can be done using one of the following commands: docker-compose start flightservice docker start flightservice_conductorFailurePerf If the container name of the FlightService has been changed in the docker-compose.yml file, the container has to be started using this name with the docker start command. The same applies for the docker-compose start command if the service name of the FlightService has been changed in the docker-compose.yml file. Provoke a termination failure of the FlightService participant while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke participant failure while executing\" The FlightService forces then its JVM to terminate itself, after booking a flight but before informing the orchestrator about it, in order to simulate a sudden failure of the system. Afterwards, the FlightService , again, has to be restarted using the same commands as above. Provoke an exception in the FlightService participant while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke exception while executing\" The FlightService throws then a RuntimeException while booking a flight to simulate unexpected behaviour of the system. Afterwards, the behaviour of the service can be observed. The easiest way is to have a look at the log of the FlightService during that time. This can be done using the following command: docker logs flightservice_conductorFailurePerf --follow 2. Saga Orchestrator Failure The Conductor server is the orchestrator in this example application. Consequently, observing the system's behaviour during orchestrator failures involves failures of this service. Provoke a failure of the Conductor server while a trip booking is being started with the following string as destination country : \"Provoke orchestrator failure while starting trip booking\" The TravelService terminates then the docker container of the Conductor server while it is executing the bookTrip request but before starting the BookTripSaga . Afterwards, the Conductor server has to be restarted manually to investigate what happens as soon as the service is running again. This can be done using one of the following commands: docker-compose start conductor-server-ui docker start conductor-server-ui If the container name of the Conductor server has been changed in the docker-compose.yml file, the container has to be started using this name. Provoke a failure of the Conductor server while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke orchestrator failure while executing\" The FlightService terminates then the docker container of the Conductor server after booking a flight, but before informing the orchestrator about it. Afterwards, the Conductor server , again, has to be restarted using the same commands as above. 3. Breach of Saga Protocol A participant might send the same message twice to the orchestrator, or even send an old one. Therefore, two scenarios have been added to the implementation that provoke sending either an old or a duplicate message to the orchestrator in order to evaluate how an implementation using Netflix Conductor handles this situation. Provoke the HotelService to send a duplicate message to the TravelService with the following string as destination country : \"Provoke duplicate message to orchestrator\" The HotelService sends then the same message, in this case the BookHotelResponse to the Conductor server . To achieve this, the HotelService send this message to the /task endpoint. Provoke the HotelService to send an old message to the TravelService with the following string as destination country : \"Provoke sending old message to orchestrator\" The HotelService creates then a new thread that waits for five minutes before it sends the same answer as before to the Conductor servrer again. To achieve this, the HotelService sends the old message, in this case the BookHotelResponse , to the provided endpoint /task . The service's logs document when it sends the old message. Code Link NetflixConductor_Implementations/NetflixConductor_FailurePerf-Evaluation","title":"Fault Tolerance Evaluation"},{"location":"NetflixConductor/NetflixConductor_FailurePerf/#netflix-conductor-failure-performance-evaluation","text":"This project is part of the evaluation of a Saga pattern implementation using Netflix Conductor . Additional sections to the original Saga Pattern Realization With Netflix Conductor have been included that simulate different failure scenarios given a particular input.","title":"Netflix Conductor Failure Performance Evaluation"},{"location":"NetflixConductor/NetflixConductor_FailurePerf/#start-the-application","text":"Run ./gradlew clean build Execute docker-compose up --no-start Execute docker-compose start elasticsearch Execute docker-compose start dynomite Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html To simulate a Saga that fails because no hotel or no flight is available , use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" Additionally, the Conductor UI can be accessed via http://localhost:5000/ and the Swagger UI of the Conductor server via http://localhost:8080/ . The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP).","title":"Start the Application"},{"location":"NetflixConductor/NetflixConductor_FailurePerf/#stop-the-application","text":"To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans","title":"Stop the Application"},{"location":"NetflixConductor/NetflixConductor_FailurePerf/#provoke-failure-scenarios","text":"The respective String has to be used as destination country in the trip booking request to provoke a participant failure. An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Provoke orchestrator failure while starting trip booking\" , \"city\" : \"Bamberg\" }, \"travellerName\" : \"Orchestrator Start\" , \"boardType\" : \"All-inclusive\" , \"customerId\" : \"4\" }","title":"Provoke Failure Scenarios"},{"location":"NetflixConductor/NetflixConductor_FailurePerf/#1-saga-participant-failure","text":"Provoke a failure of the FlightService participant before it started to execute a local transaction with the following string as destination country : \"Provoke participant failure before receiving task\" The HotelService terminates then the docker container of the FlightService while it is executing the bookHotel request. Afterwards, the FlightService has to be restarted manually to investigate what happens as soon as the service is running again. This can be done using one of the following commands: docker-compose start flightservice docker start flightservice_conductorFailurePerf If the container name of the FlightService has been changed in the docker-compose.yml file, the container has to be started using this name with the docker start command. The same applies for the docker-compose start command if the service name of the FlightService has been changed in the docker-compose.yml file. Provoke a termination failure of the FlightService participant while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke participant failure while executing\" The FlightService forces then its JVM to terminate itself, after booking a flight but before informing the orchestrator about it, in order to simulate a sudden failure of the system. Afterwards, the FlightService , again, has to be restarted using the same commands as above. Provoke an exception in the FlightService participant while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke exception while executing\" The FlightService throws then a RuntimeException while booking a flight to simulate unexpected behaviour of the system. Afterwards, the behaviour of the service can be observed. The easiest way is to have a look at the log of the FlightService during that time. This can be done using the following command: docker logs flightservice_conductorFailurePerf --follow","title":"1. Saga Participant Failure"},{"location":"NetflixConductor/NetflixConductor_FailurePerf/#2-saga-orchestrator-failure","text":"The Conductor server is the orchestrator in this example application. Consequently, observing the system's behaviour during orchestrator failures involves failures of this service. Provoke a failure of the Conductor server while a trip booking is being started with the following string as destination country : \"Provoke orchestrator failure while starting trip booking\" The TravelService terminates then the docker container of the Conductor server while it is executing the bookTrip request but before starting the BookTripSaga . Afterwards, the Conductor server has to be restarted manually to investigate what happens as soon as the service is running again. This can be done using one of the following commands: docker-compose start conductor-server-ui docker start conductor-server-ui If the container name of the Conductor server has been changed in the docker-compose.yml file, the container has to be started using this name. Provoke a failure of the Conductor server while executing a local transaction of the BookTripSaga with the following string as destination country : \"Provoke orchestrator failure while executing\" The FlightService terminates then the docker container of the Conductor server after booking a flight, but before informing the orchestrator about it. Afterwards, the Conductor server , again, has to be restarted using the same commands as above.","title":"2. Saga Orchestrator Failure"},{"location":"NetflixConductor/NetflixConductor_FailurePerf/#3-breach-of-saga-protocol","text":"A participant might send the same message twice to the orchestrator, or even send an old one. Therefore, two scenarios have been added to the implementation that provoke sending either an old or a duplicate message to the orchestrator in order to evaluate how an implementation using Netflix Conductor handles this situation. Provoke the HotelService to send a duplicate message to the TravelService with the following string as destination country : \"Provoke duplicate message to orchestrator\" The HotelService sends then the same message, in this case the BookHotelResponse to the Conductor server . To achieve this, the HotelService send this message to the /task endpoint. Provoke the HotelService to send an old message to the TravelService with the following string as destination country : \"Provoke sending old message to orchestrator\" The HotelService creates then a new thread that waits for five minutes before it sends the same answer as before to the Conductor servrer again. To achieve this, the HotelService sends the old message, in this case the BookHotelResponse , to the provided endpoint /task . The service's logs document when it sends the old message.","title":"3. Breach of Saga Protocol"},{"location":"NetflixConductor/NetflixConductor_FailurePerf/#code-link","text":"NetflixConductor_Implementations/NetflixConductor_FailurePerf-Evaluation","title":"Code Link"},{"location":"NetflixConductor/NetflixConductor_General/","text":"Saga Pattern Realization With Netflix Conductor This project includes an example implementation of the Saga pattern using Netflix Conductor . The example application represents a travel application that consists of three backend services: TravelService, HotelService and FlightService. For simplicity reasons, only the workflow for booking a trip has been implemented. Start the Application Run ./gradlew clean build Execute docker-compose up --no-start Execute docker-compose start elasticsearch Execute docker-compose start dynomite Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" Additionally, the Swagger UI of the Conductor server can be accessed via http://localhost:8080/ . The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP). Stop the Application To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans General Saga Characteristics External Compensation Trigger In order to start the compensation of a currently running Saga externally, a task that is either presently RUNNING or SCHEDULED can be marked as FAILED using the API of the Conductor server. Already COMPLETED tasks cannot be marked as FAILED and thus not be used to start the compensation workflow. The following request, supplemented with the missing information, has to be sent as POST request to the Conductor server at: http://localhost:8080/tasks { \"workflowInstanceId\" : \"ID of workflow instance that is supposed to be compensated.\" , \"taskId\" : \"ID of the task that is marked as FAILED to start compensation.\" , \"reasonForIncompletion\" : \"Reason for failure\" , \"callbackAfterSeconds\" : 0 , \"status\" : \"FAILED_WITH_TERMINAL_ERROR\" } By using the FAILED_WITH_TERMINAL_ERROR status, Conductor immediately starts the compensation workflow and does not retry the failed task even if a retry configuration exists. The TravelApplication.json insomnia file also includes this request within the ExternalCompensationTrigger directory. Monitor the Application Conductor's UI The project already includes the UI module in the Conductor Server that is started using docker-compose . The UI can be accessed via http://localhost:5000/ . Log Files Each service provides a log that contains some information about it. The logs can be accessed using the name of the relevant container. The different logs can be accessed using the following commands: Log of Command to execute TravelService docker logs travelservice_conductor HotelService docker logs hotelservice_conductor FlightService docker logs flightservice_conductor Conductor Server docker logs conductor-server-ui By using the --follow supplement, it will be continued to stream the service's output to the console. The logging level can be changed in the respective application.properties file. Metrics of the Conductor Server and the Java Client The Conductor Server publishes some metrics concerning the server and the client, like the amount of time it takes to execute a task. The necessary gradle dependency has already been added to the services. To connect the metrics registry with the logging framework, two lines within the config.properties have to be activated as they are currently commented out: conductor.additional.modules = com.netflix.conductor.contribs.metrics.MetricsRegistryModule,com.netflix.conductor.contribs.metrics.LoggingMetricsModule com.netflix.conductor.contribs.metrics.LoggingMetricsModule.reportPeriodSeconds = 15 These lines can be found beneath the Additional modules for metrics collection (optional) comment within the file. Additionally, it can be configured that the metrics will be printed into a dedicated file instead of printing it as a regular log message. To achieve that, the conductor-server-ui service within the docker-compose.yml file has to include another environment variable: LOG4J_PROP=log4j-file-appender.properties . The referenced file is already included within the project's serverAndUi directory. It configures the different logging properties. These logs could be further processed using a collector such as ElasticSearch and then visualized with Kibana UI . However, this has not been realized within this project for information about how to achieve that see Netflix Conductor's official documentation . Code Link NetflixConductor_Implementations/NetflixConductor","title":"Travel Application Realization"},{"location":"NetflixConductor/NetflixConductor_General/#saga-pattern-realization-with-netflix-conductor","text":"This project includes an example implementation of the Saga pattern using Netflix Conductor . The example application represents a travel application that consists of three backend services: TravelService, HotelService and FlightService. For simplicity reasons, only the workflow for booking a trip has been implemented.","title":"Saga Pattern Realization With Netflix Conductor"},{"location":"NetflixConductor/NetflixConductor_General/#start-the-application","text":"Run ./gradlew clean build Execute docker-compose up --no-start Execute docker-compose start elasticsearch Execute docker-compose start dynomite Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" Additionally, the Swagger UI of the Conductor server can be accessed via http://localhost:8080/ . The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP).","title":"Start the Application"},{"location":"NetflixConductor/NetflixConductor_General/#stop-the-application","text":"To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans","title":"Stop the Application"},{"location":"NetflixConductor/NetflixConductor_General/#general-saga-characteristics","text":"","title":"General Saga Characteristics"},{"location":"NetflixConductor/NetflixConductor_General/#external-compensation-trigger","text":"In order to start the compensation of a currently running Saga externally, a task that is either presently RUNNING or SCHEDULED can be marked as FAILED using the API of the Conductor server. Already COMPLETED tasks cannot be marked as FAILED and thus not be used to start the compensation workflow. The following request, supplemented with the missing information, has to be sent as POST request to the Conductor server at: http://localhost:8080/tasks { \"workflowInstanceId\" : \"ID of workflow instance that is supposed to be compensated.\" , \"taskId\" : \"ID of the task that is marked as FAILED to start compensation.\" , \"reasonForIncompletion\" : \"Reason for failure\" , \"callbackAfterSeconds\" : 0 , \"status\" : \"FAILED_WITH_TERMINAL_ERROR\" } By using the FAILED_WITH_TERMINAL_ERROR status, Conductor immediately starts the compensation workflow and does not retry the failed task even if a retry configuration exists. The TravelApplication.json insomnia file also includes this request within the ExternalCompensationTrigger directory.","title":"External Compensation Trigger"},{"location":"NetflixConductor/NetflixConductor_General/#monitor-the-application","text":"","title":"Monitor the Application"},{"location":"NetflixConductor/NetflixConductor_General/#conductors-ui","text":"The project already includes the UI module in the Conductor Server that is started using docker-compose . The UI can be accessed via http://localhost:5000/ .","title":"Conductor's UI"},{"location":"NetflixConductor/NetflixConductor_General/#log-files","text":"Each service provides a log that contains some information about it. The logs can be accessed using the name of the relevant container. The different logs can be accessed using the following commands: Log of Command to execute TravelService docker logs travelservice_conductor HotelService docker logs hotelservice_conductor FlightService docker logs flightservice_conductor Conductor Server docker logs conductor-server-ui By using the --follow supplement, it will be continued to stream the service's output to the console. The logging level can be changed in the respective application.properties file.","title":"Log Files"},{"location":"NetflixConductor/NetflixConductor_General/#metrics-of-the-conductor-server-and-the-java-client","text":"The Conductor Server publishes some metrics concerning the server and the client, like the amount of time it takes to execute a task. The necessary gradle dependency has already been added to the services. To connect the metrics registry with the logging framework, two lines within the config.properties have to be activated as they are currently commented out: conductor.additional.modules = com.netflix.conductor.contribs.metrics.MetricsRegistryModule,com.netflix.conductor.contribs.metrics.LoggingMetricsModule com.netflix.conductor.contribs.metrics.LoggingMetricsModule.reportPeriodSeconds = 15 These lines can be found beneath the Additional modules for metrics collection (optional) comment within the file. Additionally, it can be configured that the metrics will be printed into a dedicated file instead of printing it as a regular log message. To achieve that, the conductor-server-ui service within the docker-compose.yml file has to include another environment variable: LOG4J_PROP=log4j-file-appender.properties . The referenced file is already included within the project's serverAndUi directory. It configures the different logging properties. These logs could be further processed using a collector such as ElasticSearch and then visualized with Kibana UI . However, this has not been realized within this project for information about how to achieve that see Netflix Conductor's official documentation .","title":"Metrics of the Conductor Server and the Java Client"},{"location":"NetflixConductor/NetflixConductor_General/#code-link","text":"NetflixConductor_Implementations/NetflixConductor","title":"Code Link"},{"location":"NetflixConductor/NetflixConductor_ParallelExec/","text":"Netflix Conductor Parallel Execution Evaluation This project includes an example implementation of the Saga pattern using Netflix Conductor . The difference to the original Saga Pattern Realization With Netflix Conductor is the parallel execution of specific tasks instead of a sequential one. Start the Application Run ./gradlew clean build Execute docker-compose up --no-start Execute docker-compose start elasticsearch Execute docker-compose start dynomite Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" Additionally, the Swagger UI of the Conductor server can be accessed via http://localhost:8080/ . The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP). Stop the Application To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans Parallel Execution of Tasks The bookHotel and the bookFlight tasks, as well as the confirmHotel and the confirmTrip tasks, are now executed in parallel by using Conductor's provided fork and join system tasks. Additionally, the compensating workflow also runs the cancelHotel and the cancelFlight tasks in parallel. Code Link NetflixConductor_Implementations/NetflixConductor_ParallelExec-Evaluation","title":"Parallel Execution Evaluation"},{"location":"NetflixConductor/NetflixConductor_ParallelExec/#netflix-conductor-parallel-execution-evaluation","text":"This project includes an example implementation of the Saga pattern using Netflix Conductor . The difference to the original Saga Pattern Realization With Netflix Conductor is the parallel execution of specific tasks instead of a sequential one.","title":"Netflix Conductor Parallel Execution Evaluation"},{"location":"NetflixConductor/NetflixConductor_ParallelExec/#start-the-application","text":"Run ./gradlew clean build Execute docker-compose up --no-start Execute docker-compose start elasticsearch Execute docker-compose start dynomite Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" Additionally, the Swagger UI of the Conductor server can be accessed via http://localhost:8080/ . The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP).","title":"Start the Application"},{"location":"NetflixConductor/NetflixConductor_ParallelExec/#stop-the-application","text":"To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans","title":"Stop the Application"},{"location":"NetflixConductor/NetflixConductor_ParallelExec/#parallel-execution-of-tasks","text":"The bookHotel and the bookFlight tasks, as well as the confirmHotel and the confirmTrip tasks, are now executed in parallel by using Conductor's provided fork and join system tasks. Additionally, the compensating workflow also runs the cancelHotel and the cancelFlight tasks in parallel.","title":"Parallel Execution of Tasks"},{"location":"NetflixConductor/NetflixConductor_ParallelExec/#code-link","text":"NetflixConductor_Implementations/NetflixConductor_ParallelExec-Evaluation","title":"Code Link"},{"location":"NetflixConductor/NetflixConductor_Testability/","text":"Netflix Conductor Testability Evaluation This project includes an example implementation of the Saga pattern using Netflix Conductor . The original Saga Pattern Realization With Netflix Conductor has been extended by automated tests that relate to the BookTripSaga. Start the Application Run ./gradlew clean build Execute docker-compose up --no-start Execute docker-compose start elasticsearch Execute docker-compose start dynomite Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" Additionally, the Swagger UI of the Conductor server can be accessed via http://localhost:8080/ . The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP). Stop the Application To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans Testability The TravelService as well as the HotelService have a testing directory that includes several tests concerning Saga-related code. 1. Unit test Saga Definition Unit tests regarding the Saga orchestrator and the Saga definition can be found within the TravelService . However, Netflix Conductor does not provide a testing framework or allow to test the workflow definition in isolation . Therefore, it is only possible to test whether the correct workflow definition is started when executing the BookTripSaga . 2. Unit Test Saga Participant Examples for unit testing the Saga participant can be found within the HotelService . Unit tests for a Saga participant are realized using JUnit and Mockito . Code Link NetflixConductor_Implementations/NetflixConductor_Testability-Evaluation","title":"Testability Evaluation"},{"location":"NetflixConductor/NetflixConductor_Testability/#netflix-conductor-testability-evaluation","text":"This project includes an example implementation of the Saga pattern using Netflix Conductor . The original Saga Pattern Realization With Netflix Conductor has been extended by automated tests that relate to the BookTripSaga.","title":"Netflix Conductor Testability Evaluation"},{"location":"NetflixConductor/NetflixConductor_Testability/#start-the-application","text":"Run ./gradlew clean build Execute docker-compose up --no-start Execute docker-compose start elasticsearch Execute docker-compose start dynomite Execute docker-compose up Requesting trip bookings is now possible. Either use curl commands, the provided TravelApplication.json insomnia file, which includes different trip booking requests, or access the Swagger UI of the different services: Service URL to Swagger UI TravelService http://localhost:8090/swagger-ui.html HotelService http://localhost:8081/swagger-ui.html FlightService http://localhost:8082/swagger-ui.html An example for such a request: TravelRequest { \"duration\" : { \"start\" : \"2021-12-01\" , \"end\" : \"2021-12-12\" }, \"start\" : { \"country\" : \"Scotland\" , \"city\" : \"Stirling\" }, \"destination\" : { \"country\" : \"Sweden\" , \"city\" : \"Stockholm\" }, \"travellerName\" : \"Max Mustermann\" , \"boardType\" : \"breakfast\" , \"customerId\" : \"1\" } To simulate a Saga that fails because no hotel or no flight is available, use one of the following Strings as destination country in the trip booking request: \"Provoke hotel failure\" \"Provoke flight failure\" Additionally, the Swagger UI of the Conductor server can be accessed via http://localhost:8080/ . The services also provide a health and an info endpoint that show some information about the system like that the DB is up and running. These endpoints can be accessed via: Service URL to health endpoint URL to info endpoint TravelService http://localhost:8090/api/travel/monitor/health http://localhost:8090/api/travel/monitor/info HotelService http://localhost:8081/api/hotels/monitor/health http://localhost:8081/api/hotels/monitor/info FlightService http://localhost:8082/api/flights/monitor/health http://localhost:8082/api/flights/monitor/info If you are on Windows or Mac, you sometimes have to replace localhost with the default IP of your docker machine (use docker-machine ip default to get this default IP).","title":"Start the Application"},{"location":"NetflixConductor/NetflixConductor_Testability/#stop-the-application","text":"To stop the application and remove the created containers, execute the following command: docker-compose down --remove-orphans","title":"Stop the Application"},{"location":"NetflixConductor/NetflixConductor_Testability/#testability","text":"The TravelService as well as the HotelService have a testing directory that includes several tests concerning Saga-related code.","title":"Testability"},{"location":"NetflixConductor/NetflixConductor_Testability/#markdown","text":"Unit tests regarding the Saga orchestrator and the Saga definition can be found within the TravelService . However, Netflix Conductor does not provide a testing framework or allow to test the workflow definition in isolation . Therefore, it is only possible to test whether the correct workflow definition is started when executing the BookTripSaga .","title":"1. Unit test Saga definition"},{"location":"NetflixConductor/NetflixConductor_Testability/#2-unit-test-saga-participant","text":"Examples for unit testing the Saga participant can be found within the HotelService . Unit tests for a Saga participant are realized using JUnit and Mockito .","title":"2. Unit Test Saga Participant"},{"location":"NetflixConductor/NetflixConductor_Testability/#code-link","text":"NetflixConductor_Implementations/NetflixConductor_Testability-Evaluation","title":"Code Link"}]}